{"version":3,"file":"recorder-audio-worklet-BKRkq2ay.js","sources":["../../node_modules/recorder-audio-worklet/build/es2019/factories/add-recorder-audio-worklet-module.js","../../node_modules/recorder-audio-worklet/build/es2019/factories/listener.js","../../node_modules/recorder-audio-worklet/build/es2019/factories/post-message-factory.js","../../node_modules/recorder-audio-worklet/build/es2019/factories/recorder-audio-worklet-node-factory.js","../../node_modules/recorder-audio-worklet/build/es2019/functions/validate-state.js","../../node_modules/recorder-audio-worklet/build/es2019/worklet/worklet.js","../../node_modules/recorder-audio-worklet/build/es2019/module.js"],"sourcesContent":["export const createAddRecorderAudioWorkletModule = (blobConstructor, urlConstructor, worklet) => {\n    return async (addAudioWorkletModule) => {\n        const blob = new blobConstructor([worklet], { type: 'application/javascript; charset=utf-8' });\n        const url = urlConstructor.createObjectURL(blob);\n        try {\n            await addAudioWorkletModule(url);\n        }\n        finally {\n            urlConstructor.revokeObjectURL(url);\n        }\n    };\n};\n//# sourceMappingURL=add-recorder-audio-worklet-module.js.map","export const createListener = (ongoingRequests) => {\n    return ({ data: message }) => {\n        const { id } = message;\n        if (id !== null) {\n            const ongoingRequest = ongoingRequests.get(id);\n            if (ongoingRequest !== undefined) {\n                const { reject, resolve } = ongoingRequest;\n                ongoingRequests.delete(id);\n                if (message.error === undefined) {\n                    resolve(message.result);\n                }\n                else {\n                    reject(new Error(message.error.message));\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=listener.js.map","export const createPostMessageFactory = (generateUniqueNumber) => {\n    return (ongoingRequests, port) => {\n        return (message, transferables = []) => {\n            return new Promise((resolve, reject) => {\n                const id = generateUniqueNumber(ongoingRequests);\n                ongoingRequests.set(id, { reject, resolve });\n                port.postMessage({ id, ...message }, transferables);\n            });\n        };\n    };\n};\n//# sourceMappingURL=post-message-factory.js.map","export const createRecorderAudioWorkletNodeFactory = (createListener, createPostMessage, on, validateState) => {\n    return (audioWorkletNodeConstructor, context, options = {}) => {\n        const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', {\n            ...options,\n            channelCountMode: 'explicit',\n            numberOfInputs: 1,\n            numberOfOutputs: 0\n        });\n        const ongoingRequests = new Map();\n        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n        audioWorkletNode.port.start();\n        let state = 'inactive';\n        Object.defineProperties(audioWorkletNode, {\n            pause: {\n                get() {\n                    return async () => {\n                        validateState(['recording'], state);\n                        state = 'paused';\n                        return postMessage({\n                            method: 'pause'\n                        });\n                    };\n                }\n            },\n            port: {\n                get() {\n                    throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n                }\n            },\n            record: {\n                get() {\n                    return async (encoderPort) => {\n                        validateState(['inactive'], state);\n                        state = 'recording';\n                        return postMessage({\n                            method: 'record',\n                            params: { encoderPort }\n                        }, [encoderPort]);\n                    };\n                }\n            },\n            resume: {\n                get() {\n                    return async () => {\n                        validateState(['paused'], state);\n                        state = 'recording';\n                        return postMessage({\n                            method: 'resume'\n                        });\n                    };\n                }\n            },\n            stop: {\n                get() {\n                    return async () => {\n                        validateState(['paused', 'recording'], state);\n                        state = 'stopped';\n                        try {\n                            await postMessage({ method: 'stop' });\n                        }\n                        finally {\n                            unsubscribe();\n                        }\n                    };\n                }\n            }\n        });\n        return audioWorkletNode;\n    };\n};\n//# sourceMappingURL=recorder-audio-worklet-node-factory.js.map","export const validateState = (expectedStates, currentState) => {\n    if (!expectedStates.includes(currentState)) {\n        throw new Error(`Expected the state to be ${expectedStates\n            .map((expectedState) => `\"${expectedState}\"`)\n            .join(' or ')} but it was \"${currentState}\".`);\n    }\n};\n//# sourceMappingURL=validate-state.js.map","// This is the minified and stringified code of the recorder-audio-worklet-processor package.\nexport const worklet = `(()=>{\"use strict\";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._numberOfChannels=0,this._state=\"inactive\",this.port.onmessage=e=>{let{data:t}=e;\"pause\"===t.method?\"active\"===this._state||\"recording\"===this._state?(this._state=\"paused\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"record\"===t.method?\"inactive\"===this._state?(this._encoderPort=t.params.encoderPort,this._state=\"active\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"resume\"===t.method?\"paused\"===this._state?(this._state=\"active\",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):\"stop\"===t.method?\"active\"!==this._state&&\"paused\"!==this._state&&\"recording\"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(t.id):(this._stop(this._encoderPort),this._sendAcknowledgement(t.id)):\"number\"==typeof t.id&&this.port.postMessage({error:{code:-32601,message:\"The requested method is not supported.\"},id:t.id})}}process(e){let[t]=e;if(\"inactive\"===this._state||\"paused\"===this._state)return!0;if(\"active\"===this._state){if(void 0===t)throw new Error(\"No channelData was received for the first input.\");if(0===t.length)return!0;this._state=\"recording\"}if(\"recording\"===this._state&&null!==this._encoderPort){if(void 0===t)throw new Error(\"No channelData was received for the first input.\");return 0===t.length?this._encoderPort.postMessage(Array.from({length:this._numberOfChannels},(()=>128))):(this._encoderPort.postMessage(t,t.map((e=>{let{buffer:t}=e;return t}))),this._numberOfChannels=t.length),!0}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:\"The internal state does not allow to process the given message.\"},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state=\"stopped\"}}e.parameterDescriptors=[],registerProcessor(\"recorder-audio-worklet-processor\",e)})();`; // tslint:disable-line:max-line-length\n//# sourceMappingURL=worklet.js.map","import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { on } from 'subscribable-things';\nimport { isSupported } from 'worker-factory';\nimport { createAddRecorderAudioWorkletModule } from './factories/add-recorder-audio-worklet-module';\nimport { createListener } from './factories/listener';\nimport { createPostMessageFactory } from './factories/post-message-factory';\nimport { createRecorderAudioWorkletNodeFactory } from './factories/recorder-audio-worklet-node-factory';\nimport { validateState } from './functions/validate-state';\nimport { worklet } from './worklet/worklet';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nexport const addRecorderAudioWorkletModule = createAddRecorderAudioWorkletModule(Blob, URL, worklet);\nexport const createRecorderAudioWorkletNode = createRecorderAudioWorkletNodeFactory(createListener, createPostMessageFactory(generateUniqueNumber), on, validateState);\nexport { isSupported };\n//# sourceMappingURL=module.js.map"],"names":["createAddRecorderAudioWorkletModule","blobConstructor","urlConstructor","worklet","addAudioWorkletModule","blob","url","createListener","ongoingRequests","message","id","ongoingRequest","reject","resolve","createPostMessageFactory","generateUniqueNumber","port","transferables","createRecorderAudioWorkletNodeFactory","createPostMessage","on","validateState","audioWorkletNodeConstructor","context","options","audioWorkletNode","postMessage","unsubscribe","state","encoderPort","expectedStates","currentState","expectedState","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}