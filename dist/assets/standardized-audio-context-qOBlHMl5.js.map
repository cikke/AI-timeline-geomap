{"version":3,"file":"standardized-audio-context-qOBlHMl5.js","sources":["../../node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","../../node_modules/standardized-audio-context/build/es2019/globals.js","../../node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","../../node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","../../node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","../../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","../../node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js","../../node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","../../node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","../../node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","../../node_modules/standardized-audio-context/build/es2019/constants.js","../../node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","../../node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/gain-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","../../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js","../../node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js","../../node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","../../node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","../../node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","../../node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","../../node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js","../../node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","../../node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","../../node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","../../node_modules/standardized-audio-context/build/es2019/read-only-map.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","../../node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","../../node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","../../node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","../../node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","../../node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","../../node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","../../node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","../../node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","../../node_modules/standardized-audio-context/build/es2019/guards/delay-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","../../node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","../../node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","../../node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","../../node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","../../node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","../../node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","../../node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","../../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","../../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","../../node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","../../node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","../../node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js","../../node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js","../../node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","../../node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","../../node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","../../node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","../../node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","../../node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","../../node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","../../node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js","../../node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","../../node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js","../../node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","../../node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","../../node_modules/standardized-audio-context/build/es2019/factories/window.js","../../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","../../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","../../node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","../../node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","../../node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js","../../node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","../../node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js","../../node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","../../node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","../../node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","../../node_modules/standardized-audio-context/build/es2019/module.js"],"sourcesContent":["export const createAbortError = () => new DOMException('', 'AbortError');\n//# sourceMappingURL=abort-error.js.map","export const createAddActiveInputConnectionToAudioNode = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n    };\n};\n//# sourceMappingURL=add-active-input-connection-to-audio-node.js.map","export const createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n    return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n        const activeInputs = [];\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set());\n        }\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n//# sourceMappingURL=add-audio-node-connections.js.map","export const createAddAudioParamConnections = (audioParamConnectionsStore) => {\n    return (audioParam, audioParamRenderer) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n//# sourceMappingURL=add-audio-param-connections.js.map","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\n//# sourceMappingURL=globals.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\nexport const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {\n    let index = 0;\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const nativeContext = getNativeContext(context);\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise = nativeContext.audioWorklet === undefined\n            ? fetchSource(moduleURL)\n                .then(([source, absoluteUrl]) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * ${ importStatements };\n                 * ((a, b) => {\n                 *     (a[b] = a[b] || [ ]).push(\n                 *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                 *             ${ sourceWithoutImportStatements }\n                 *         }\n                 *     );\n                 * })(window, '_AWGS');\n                 * ```\n                 */\n                // tslint:disable-next-line:max-line-length\n                const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n                // @todo Evaluating the given source code is a possible security problem.\n                return evaluateSource(wrappedSource);\n            })\n                .then(() => {\n                const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n                if (evaluateAudioWorkletGlobalScope === undefined) {\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    throw new SyntaxError();\n                }\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n                }, undefined, (name, processorCtor) => {\n                    if (name.trim() === '') {\n                        throw createNotSupportedError();\n                    }\n                    const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                    if (nodeNameToProcessorConstructorMap !== undefined) {\n                        if (nodeNameToProcessorConstructorMap.has(name)) {\n                            throw createNotSupportedError();\n                        }\n                        verifyProcessorCtor(processorCtor);\n                        verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                        nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                    }\n                    else {\n                        verifyProcessorCtor(processorCtor);\n                        verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                        NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                    }\n                }, nativeContext.sampleRate, undefined, undefined));\n            })\n            : Promise.all([\n                fetchSource(moduleURL),\n                Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))\n            ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                const currentIndex = index + 1;\n                index = currentIndex;\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * This is the unminified version of the code used below.\n                 *\n                 * ```js\n                 * class extends AudioWorkletProcessor {\n                 *\n                 *     __buffers = new WeakSet();\n                 *\n                 *     constructor () {\n                 *         super();\n                 *\n                 *         this.port.postMessage = ((postMessage) => {\n                 *             return (message, transferables) => {\n                 *                 const filteredTransferables = (transferables)\n                 *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                 *                     : transferables;\n                 *\n                 *                 return postMessage.call(this.port, message, filteredTransferables);\n                 *              };\n                 *         })(this.port.postMessage);\n                 *     }\n                 * }\n                 * ```\n                 */\n                const patchedAudioWorkletProcessor = isSupportingPostMessage\n                    ? 'AudioWorkletProcessor'\n                    : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                /*\n                 * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                 *\n                 * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                 *\n                 * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })(\n                 *     ${ patchedAudioWorkletProcessor },\n                 *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *         __collectBuffers = (array) => {\n                 *             array.forEach((element) => this.__buffers.add(element.buffer));\n                 *         };\n                 *\n                 *         process (inputs, outputs, parameters) {\n                 *             inputs.forEach(this.__collectBuffers);\n                 *             outputs.forEach(this.__collectBuffers);\n                 *             this.__collectBuffers(Object.values(parameters));\n                 *\n                 *             return super.process(\n                 *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                 *                 outputs,\n                 *                 parameters\n                 *             );\n                 *         }\n                 *\n                 *     })\n                 * );\n                 *\n                 * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                 *\n                 *     process () {\n                 *         return false;\n                 *     }\n                 *\n                 * })`\n                 * ```\n                 */\n                const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                const bufferRegistration = isSupportingPostMessage\n                    ? ''\n                    : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                return nativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => {\n                    if (isNativeOfflineAudioContext(nativeContext)) {\n                        return nativeContext;\n                    }\n                    // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                    const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n                    return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                })\n                    .then((nativeContextOrBackupOfflineAudioContext) => {\n                    if (nativeAudioWorkletNodeConstructor === null) {\n                        throw new SyntaxError();\n                    }\n                    try {\n                        // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                        new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                    }\n                    catch {\n                        throw new SyntaxError();\n                    }\n                })\n                    .finally(() => URL.revokeObjectURL(url));\n            });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n            if (updatedResolvedRequestsOfContext === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                updatedResolvedRequestsOfContext.add(moduleURL);\n            }\n        })\n            .finally(() => {\n            const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n            if (updatedOngoingRequestsOfContext !== undefined) {\n                updatedOngoingRequestsOfContext.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=add-audio-worklet-module.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=get-value-for-key.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=pick-element-from-set.js.map","import { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\nexport const deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\n//# sourceMappingURL=delete-passive-input-connection-to-audio-node.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = (audioNode) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n//# sourceMappingURL=set-internal-state-to-active.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=audio-worklet-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = (audioNode) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n//# sourceMappingURL=set-internal-state-to-passive.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=set-internal-state-to-passive-when-necessary.js.map","import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nexport const createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) => {\n    const tailTimeTimeoutIds = new WeakMap();\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n        const eventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            }\n            else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n                const tailTime = getAudioNodeTailTime(destination);\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                }\n                else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n                    tailTimeTimeoutIds.set(destination, setTimeout(() => {\n                        if (isActiveAudioNode(destination)) {\n                            setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                        }\n                    }, tailTime * 1000));\n                }\n            }\n        };\n        if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n            eventListeners.add(eventListener);\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            }\n            else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=add-connection-to-audio-node.js.map","export const createAddPassiveInputConnectionToAudioNode = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        }\n        else {\n            insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n        }\n    };\n};\n//# sourceMappingURL=add-passive-input-connection-to-audio-node.js.map","export const createAddSilentConnection = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n//# sourceMappingURL=add-silent-connection.js.map","export const createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=add-unrendered-audio-worklet-node.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=is-owned-by-context.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","export const createIndexSizeError = () => new DOMException('', 'IndexSizeError');\n//# sourceMappingURL=index-size-error.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=wrap-audio-buffer-get-channel-data-method.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return ((instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-constructor.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=constants.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n//# sourceMappingURL=is-active-audio-node.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n    return class AudioBufferSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline ? createAudioBufferSourceNodeRenderer() : null));\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-constructor.js.map","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-buffer-source-node-renderer-factory.js.map","export const isAudioBufferSourceNode = (audioNode) => {\n    return 'playbackRate' in audioNode;\n};\n//# sourceMappingURL=audio-buffer-source-node.js.map","export const isBiquadFilterNode = (audioNode) => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n//# sourceMappingURL=biquad-filter-node.js.map","export const isConstantSourceNode = (audioNode) => {\n    return 'offset' in audioNode;\n};\n//# sourceMappingURL=constant-source-node.js.map","export const isGainNode = (audioNode) => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n//# sourceMappingURL=gain-node.js.map","export const isOscillatorNode = (audioNode) => {\n    return 'detune' in audioNode && 'frequency' in audioNode && !('gain' in audioNode);\n};\n//# sourceMappingURL=oscillator-node.js.map","export const isStereoPannerNode = (audioNode) => {\n    return 'pan' in audioNode;\n};\n//# sourceMappingURL=stereo-panner-node.js.map","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n//# sourceMappingURL=get-audio-node-connections.js.map","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n//# sourceMappingURL=get-audio-param-connections.js.map","import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\nexport const deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n    activeInputs.forEach((connections) => connections.forEach(([source]) => {\n        if (!trace.includes(audioNode)) {\n            deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n        }\n    }));\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n            // Bug #149: Safari does not yet support the detune AudioParam.\n            audioNode.playbackRate\n        ]\n        : isAudioWorkletNode(audioNode)\n            ? Array.from(audioNode.parameters.values())\n            : isBiquadFilterNode(audioNode)\n                ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n                : isConstantSourceNode(audioNode)\n                    ? [audioNode.offset]\n                    : isGainNode(audioNode)\n                        ? [audioNode.gain]\n                        : isOscillatorNode(audioNode)\n                            ? [audioNode.detune, audioNode.frequency]\n                            : isStereoPannerNode(audioNode)\n                                ? [audioNode.pan]\n                                : [];\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n//# sourceMappingURL=deactivate-active-audio-node-input-connections.js.map","import { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\nexport const deactivateAudioGraph = (context) => {\n    deactivateActiveAudioNodeInputConnections(context.destination, []);\n};\n//# sourceMappingURL=deactivate-audio-graph.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return (latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback')));\n};\n//# sourceMappingURL=is-valid-latency-hint.js.map","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null));\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=audio-destination-node-constructor.js.map","export const createAudioDestinationNodeRenderer = (renderInputsOfAudioNode) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap();\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext) {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n//# sourceMappingURL=audio-destination-node-renderer-factory.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n                isScriptProcessorNodeCreated = true;\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                        lastOrientation = orientation;\n                    }\n                    const positon = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                        lastPosition = positon;\n                    }\n                };\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index) => (value) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index) => (value) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input, initialValue, setValue) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return initialValue;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n                overwriteAccessors(audioParam, 'value', (get) => () => get.call(audioParam), (set) => (value) => {\n                    try {\n                        set.call(audioParam, value);\n                    }\n                    catch (err) {\n                        if (err.code !== 9) {\n                            throw err;\n                        }\n                    }\n                    createScriptProcessorNode();\n                    if (isOffline) {\n                        // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                        setValue(value);\n                    }\n                });\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n                    return (...args) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n                        createScriptProcessorNode();\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n                return audioParam;\n            };\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-listener-factory.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=audio-node.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=audio-node-output-connection.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=insert-element-in-set.js.map","import { insertElementInSet } from './insert-element-in-set';\nexport const addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n//# sourceMappingURL=add-active-input-connection-to-audio-param.js.map","import { insertElementInSet } from './insert-element-in-set';\nexport const addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);\n    }\n};\n//# sourceMappingURL=add-passive-input-connection-to-audio-param.js.map","export const isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n//# sourceMappingURL=native-audio-node-faker.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=connect-native-audio-node-to-native-audio-node.js.map","export const deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\n//# sourceMappingURL=delete-active-input-connection.js.map","import { pickElementFromSet } from './pick-element-from-set';\nexport const deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n//# sourceMappingURL=delete-active-input-connection-to-audio-param.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n//# sourceMappingURL=delete-event-listeners-of-audio-node.js.map","import { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\nexport const deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\n//# sourceMappingURL=delete-passive-input-connection-to-audio-param.js.map","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=disconnect-native-audio-node-from-native-audio-node.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=get-native-audio-node.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=get-native-audio-param.js.map","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n//# sourceMappingURL=is-part-of-a-cycle.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=is-passive-audio-node.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor) => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        }\n        else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n            channelData[0] = 1;\n            channelData[1] = 1;\n            const source = nativeAudioContext.createBufferSource();\n            source.buffer = ones;\n            source.loop = true;\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n                if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                    resolve(true);\n                }\n                else {\n                    resolve(false);\n                }\n                source.stop();\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n            source.start();\n        }\n    });\n};\n//# sourceMappingURL=test-audio-node-disconnect-method-support.js.map","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n    const counts = new Map();\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n//# sourceMappingURL=visit-each-audio-node-once.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=native-audio-node.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination, output = 0, input = 0) => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === undefined));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=wrap-audio-node-disconnect-method.js.map","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }\n        else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n        return true;\n    }\n    return false;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], false];\n    }\n    return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source, isOffline) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        destinations.push(outputConnection[0]);\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n    return destinations;\n};\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n    return destinations;\n};\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => outputConnection[0] === destination &&\n        (output === undefined || outputConnection[1] === output) &&\n        (input === undefined || outputConnection[2] === input))\n        .map((outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return outputConnection[0];\n    });\n};\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) => {\n    return class AudioNode extends eventTargetConstructor {\n        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        // tslint:disable-next-line:invalid-void\n        connect(destination, output = 0, input = 0) {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    const isPassive = isPassiveAudioNode(this);\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err;\n                }\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], destination);\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err;\n            }\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            let destinations;\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-node-constructor.js.map","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return defaultValue;\n            },\n            get maxValue() {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array.from(automationEventList).pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n                const currentTime = audioNode.context.currentTime;\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                const currentTime = audioNode.context.currentTime;\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=audio-param-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=audio-param-renderer.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=read-only-map.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options) {\n            var _a;\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed'\n                ? nativeContext\n                : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null));\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n            const { activeInputs } = getAudioNodeConnections(this);\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=audio-worklet-node-constructor.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=copy-from-channel.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=copy-to-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = typeof y === 'number' ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=create-nested-arrays.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=get-audio-worklet-processor.js.map","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                colno: error.colno,\n                filename: error.filename,\n                lineno: error.lineno,\n                message: error.message\n            }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map","export const createCacheTestResult = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        try {\n            const synchronousTestResult = test();\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                    ongoingTests.delete(tester);\n                    testResults.set(tester, finalTestResult);\n                    return finalTestResult;\n                });\n            }\n            testResults.set(tester, synchronousTestResult);\n            return synchronousTestResult;\n        }\n        catch {\n            testResults.set(tester, false);\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=cache-test-result.js.map","export const createConnectAudioParam = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n//# sourceMappingURL=connect-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=connect-multiple-outputs.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=convert-number-to-unsigned-long.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    }\n                    else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        }\n        else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n//# sourceMappingURL=decrement-cycle-counter.js.map","export const createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n    };\n};\n//# sourceMappingURL=delete-active-input-connection-to-audio-node.js.map","export const createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n//# sourceMappingURL=delete-unrendered-audio-worklet-node.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=delay-node.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(chain, nextLink) {\n        const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n        const { outputs } = getAudioNodeConnections(audioNode);\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n//# sourceMappingURL=detect-cycles.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=disconnect-multiple-outputs.js.map","export const createEvaluateSource = (window) => {\n    return (source) => new Promise((resolve, reject) => {\n        if (window === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n            return;\n        }\n        const head = window.document.head;\n        if (head === null) {\n            // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n            reject(new SyntaxError());\n        }\n        else {\n            const script = window.document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=evaluate-source.js.map","export const createEventTargetConstructor = (wrapEventListener) => {\n    return class EventTarget {\n        constructor(_nativeEventTarget) {\n            this._nativeEventTarget = _nativeEventTarget;\n            this._listeners = new WeakMap();\n        }\n        addEventListener(type, listener, options) {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n        dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n        removeEventListener(type, listener, options) {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n//# sourceMappingURL=event-target-constructor.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=expose-current-frame-and-current-time.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        }\n        catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=fetch-source.js.map","export const createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore, getValueForKey) => {\n    return (nativeAudioWorkletNode) => getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=get-active-audio-worklet-node-inputs.js.map","export const createGetAudioNodeRenderer = (getAudioNodeConnections) => {\n    return (audioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n        return audioNodeConnections.renderer;\n    };\n};\n//# sourceMappingURL=get-audio-node-renderer.js.map","export const createGetAudioNodeTailTime = (audioNodeTailTimeStore) => {\n    return (audioNode) => { var _a; return (_a = audioNodeTailTimeStore.get(audioNode)) !== null && _a !== void 0 ? _a : 0; };\n};\n//# sourceMappingURL=get-audio-node-tail-time.js.map","export const createGetAudioParamRenderer = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n        return audioParamConnections.renderer;\n    };\n};\n//# sourceMappingURL=get-audio-param-renderer.js.map","export const createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n//# sourceMappingURL=get-backup-offline-audio-context.js.map","export const createInvalidStateError = () => new DOMException('', 'InvalidStateError');\n//# sourceMappingURL=invalid-state-error.js.map","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = (contextStore) => {\n    return (context) => {\n        const nativeContext = contextStore.get(context);\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n        return (nativeContext);\n    };\n};\n//# sourceMappingURL=get-native-context.js.map","export const createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n        return backupOfflineAudioContext;\n    };\n};\n//# sourceMappingURL=get-or-create-backup-offline-audio-context.js.map","export const createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n        return unrenderedAudioWorkletNodes;\n    };\n};\n//# sourceMappingURL=get-unrendered-audio-worklet-nodes.js.map","export const createInvalidAccessError = () => new DOMException('', 'InvalidAccessError');\n//# sourceMappingURL=invalid-access-error.js.map","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n                            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                        }\n                        else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n                cycleCounters.set(audioNode, count);\n            }\n            else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n//# sourceMappingURL=increment-cycle-counter-factory.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=is-native-audio-context.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n//# sourceMappingURL=is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n//# sourceMappingURL=is-native-audio-param.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n//# sourceMappingURL=is-native-offline-audio-context.js.map","export const createIsSecureContext = (window) => window !== null && window.isSecureContext;\n//# sourceMappingURL=is-secure-context.js.map","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n    return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n            super(context, true, nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=media-stream-audio-source-node-constructor.js.map","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            let nativeAudioContext;\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            }\n            catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, 2);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                        ? 512 / sampleRate\n                        : latencyHint === 'interactive' || latencyHint === undefined\n                            ? 256 / sampleRate\n                            : latencyHint === 'playback'\n                                ? 1024 / sampleRate\n                                : /*\n                                   * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                                   * ScriptProcessorNode.\n                                   */\n                                    (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n                this._nativeGainNode.gain.value = 1e-37;\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            }\n            else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n                deactivateAudioGraph(this);\n            });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err;\n            });\n        }\n    };\n};\n//# sourceMappingURL=minimal-audio-context-constructor.js.map","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n    return class MinimalBaseAudioContext extends eventTargetConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=minimal-base-audio-context-constructor.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=test-promise-support.js.map","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set();\n        nativeAudioNode.connect = ((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination, output = 0, input = 0) => {\n                const wasDisconnected = connections.size === 0;\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    connect.call(nativeAudioNode, destination, output, input);\n                    insertElementInSet(connections, [destination, output, input], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n                    return destination;\n                }\n                connect.call(nativeAudioNode, destination, output);\n                insertElementInSet(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n                return;\n            };\n        })(nativeAudioNode.connect);\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput, output, input) => {\n                const wasConnected = connections.size > 0;\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n                    connections.clear();\n                }\n                else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    disconnect.call(nativeAudioNode, destinationOrOutput);\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n                    }\n                    else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        disconnect.call(nativeAudioNode, destinationOrOutput, output);\n                    }\n                    for (const connection of connections) {\n                        if (connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n                const isDisconnected = connections.size === 0;\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n        return nativeAudioNode;\n    };\n};\n//# sourceMappingURL=monitor-connections.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=assign-native-audio-node-option.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=assign-native-audio-node-options.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=native-audio-buffer-constructor.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=assign-native-audio-node-audio-param-value.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=native-audio-buffer-source-node-factory.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=native-audio-context-constructor.js.map","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            }\n            catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n        overwriteAccessors(gainNode, 'channelCount', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            try {\n                nativeAudioDestinationNode.channelCount = value;\n            }\n            catch (err) {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                if (value > nativeAudioDestinationNode.maxChannelCount) {\n                    throw err;\n                }\n            }\n        });\n        overwriteAccessors(gainNode, 'channelCountMode', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelCountMode = value;\n        });\n        overwriteAccessors(gainNode, 'channelInterpretation', (get) => () => get.call(gainNode), (set) => (value) => {\n            set.call(gainNode, value);\n            nativeAudioDestinationNode.channelInterpretation = value;\n        });\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n        return gainNode;\n    };\n};\n//# sourceMappingURL=native-audio-destination-node.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=native-audio-worklet-node-constructor.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=test-clonability-of-audio-worklet-node-options.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeContext, name, options);\n                const patchedEventListeners = new Map();\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = typeof value === 'function' ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = typeof args[1] === 'function'\n                                ? args[1]\n                                : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n                                            unpatchedEventListener(event);\n                                        }\n                                        else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err;\n            }\n        }\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-factory.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=compute-buffer-size.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=clone-audio-worklet-node-options.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=create-audio-worklet-processor-promise.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=create-audio-worklet-processor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n        const activeInputIndexes = new Map();\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n                                return input;\n                            }\n                            const count = activeInputIndexes.get(index);\n                            if (count === undefined) {\n                                return [];\n                            }\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                }\n                                else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n                            colno: error.colno,\n                            filename: error.filename,\n                            lineno: error.lineno,\n                            message: error.message\n                        }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-faker-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=native-channel-merger-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=wrap-channel-splitter-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNode = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n    return nativeChannelSplitterNode;\n};\n//# sourceMappingURL=native-channel-splitter-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=native-constant-source-node-factory.js.map","export const interceptConnections = (original, interceptor) => {\n    original.connect = interceptor.connect.bind(interceptor);\n    original.disconnect = interceptor.disconnect.bind(interceptor);\n    return original;\n};\n//# sourceMappingURL=intercept-connections.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNode = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n    return nativeGainNode;\n};\n//# sourceMappingURL=native-gain-node.js.map","export const createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n    return nativeMediaStreamAudioSourceNode;\n};\n//# sourceMappingURL=native-media-stream-audio-source-node.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=native-offline-audio-context-constructor.js.map","export const createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n//# sourceMappingURL=native-script-processor-node.js.map","export const createNotSupportedError = () => new DOMException('', 'NotSupportedError');\n//# sourceMappingURL=not-supported-error.js.map","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n        audioParamRenderer.replay(nativeAudioParam);\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n//# sourceMappingURL=render-automation.js.map","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n        await Promise.all(audioNodeConnections.activeInputs\n            .map((connections, input) => Array.from(connections).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n            const destination = audioNode.context.destination;\n            if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n            }\n        }))\n            .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-node.js.map","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n    return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {\n        const audioParamConnections = getAudioParamConnections(audioParam);\n        await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n            const audioNodeRenderer = getAudioNodeRenderer(source);\n            const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n            if (!isPartOfACycle(source)) {\n                renderedNativeAudioNode.connect(nativeAudioParam, output);\n            }\n        }));\n    };\n};\n//# sourceMappingURL=render-inputs-of-audio-param.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=render-native-offline-audio-context.js.map","export const createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n//# sourceMappingURL=set-active-audio-worklet-node-inputs.js.map","// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=test-audio-buffer-constructor-support.js.map","// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n        const blob = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'], {\n            type: 'application/javascript; charset=utf-8'\n        });\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n            await offlineAudioContext.startRendering();\n            // Bug #197: Safari does not deliver the messages before the promise returned by startRendering() resolves.\n            await new Promise((resolve) => setTimeout(resolve));\n        }\n        catch {\n            // Ignore errors.\n        }\n        finally {\n            URL.revokeObjectURL(url);\n        }\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n//# sourceMappingURL=test-audio-worklet-processor-post-message-support.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=test-offline-audio-context-current-time-support.js.map","export const createUnknownError = () => new DOMException('', 'UnknownError');\n//# sourceMappingURL=unknown-error.js.map","export const createWindow = () => (typeof window === 'undefined' ? null : window);\n//# sourceMappingURL=window.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n        overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', (get) => () => {\n            const value = get.call(nativeAudioBufferSourceNode);\n            return value === nullifiedBuffer ? null : value;\n        }, (set) => (value) => {\n            return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n        });\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-stop-method-nullified-buffer.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=wrap-channel-merger-node.js.map","export const getFirstSample = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n    return buffer[0];\n};\n//# sourceMappingURL=get-first-sample.js.map","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n    const { get, set } = Object.getOwnPropertyDescriptor(prototype, property);\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n//# sourceMappingURL=overwrite-accessors.js.map","export const sanitizeAudioWorkletNodeOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: options.outputChannelCount !== undefined\n            ? options.outputChannelCount\n            : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                    [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n//# sourceMappingURL=sanitize-audio-worklet-node-options.js.map","export const setValueAtTimeUntilPossible = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    }\n    catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n//# sourceMappingURL=set-value-at-time-until-possible.js.map","export const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.start();\n    try {\n        nativeAudioBufferSourceNode.start();\n    }\n    catch {\n        return true;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","export const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.start();\n    try {\n        nativeAudioBufferSourceNode.stop();\n    }\n    catch {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=test-audio-buffer-source-node-stop-method-nullified-buffer-support.js.map","export const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    }\n    catch (err) {\n        return err instanceof RangeError;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n    try {\n        nativeAudioBufferSourceNode.stop();\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    }\n    catch (err) {\n        return err instanceof RangeError;\n    }\n    return false;\n};\n//# sourceMappingURL=test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","export const testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n        port2.close();\n    }\n};\n//# sourceMappingURL=test-audio-worklet-node-options-clonability.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","import { interceptConnections } from './intercept-connections';\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = nativeContext.createGain();\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                }\n                catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            }\n            else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","export const wrapEventListener = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n//# sourceMappingURL=wrap-event-listener.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet(), sanitizePeriodicWaveOptions);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = isSecureContext\n    ? createAddAudioWorkletModule(cacheTestResult, createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, new WeakMap(), new WeakMap(), createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), \n    // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n    window)\n    : undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener)\n    : undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor), testDomExceptionConstructorSupport, createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=module.js.map"],"names":["createAbortError","createAddActiveInputConnectionToAudioNode","insertElementInSet","activeInputs","source","output","input","eventListener","ignoreDuplicates","activeInputConnection","createAddAudioNodeConnections","audioNodeConnectionsStore","audioNode","audioNodeRenderer","nativeAudioNode","i","createAddAudioParamConnections","audioParamConnectionsStore","audioParam","audioParamRenderer","ACTIVE_AUDIO_NODE_STORE","AUDIO_NODE_CONNECTIONS_STORE","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","handler","isConstructible","constructible","proxy","IMPORT_STATEMENT_REGEX","splitImportStatements","url","importStatements","sourceWithoutImportStatements","result","unresolvedUrl","importStatementWithResolvedUrl","verifyParameterDescriptors","parameterDescriptors","verifyProcessorCtor","processorCtor","createAddAudioWorkletModule","cacheTestResult","createNotSupportedError","evaluateSource","exposeCurrentFrameAndCurrentTime","fetchSource","getNativeContext","getOrCreateBackupOfflineAudioContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","ongoingRequests","resolvedRequests","testAudioWorkletProcessorPostMessageSupport","window","index","context","moduleURL","options","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","nativeContext","promise","absoluteUrl","wrappedSource","evaluateAudioWorkletGlobalScope","name","nodeNameToProcessorConstructorMap","isSupportingPostMessage","currentIndex","blob","backupOfflineAudioContext","nativeContextOrBackupOfflineAudioContext","updatedResolvedRequestsOfContext","updatedOngoingRequestsOfContext","getValueForKey","map","key","value","pickElementFromSet","set","predicate","matchingElements","matchingElement","deletePassiveInputConnectionToAudioNode","passiveInputs","passiveInputConnections","matchingConnection","passiveInputConnection","getEventListenersOfAudioNode","setInternalStateToActive","isAudioWorkletNode","setInternalStateToPassive","setInternalStateToPassiveWhenNecessary","connections","createAddConnectionToAudioNode","addActiveInputConnectionToAudioNode","addPassiveInputConnectionToAudioNode","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnectionToAudioNode","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioNodeTailTime","getNativeAudioNode","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","tailTimeTimeoutIds","destination","isOffline","outputs","eventListeners","isActive","nativeDestinationAudioNode","nativeSourceAudioNode","partialConnection","tailTime","tailTimeTimeoutId","outputConnection","createAddPassiveInputConnectionToAudioNode","createAddSilentConnection","createNativeGainNode","nativeAudioScheduledSourceNode","nativeGainNode","disconnect","createAddUnrenderedAudioWorkletNode","getUnrenderedAudioWorkletNodes","audioWorkletNode","isOwnedByContext","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","createIndexSizeError","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","err","DEFAULT_OPTIONS","createAudioBufferConstructor","audioBufferStore","nativeAudioBufferConstructor","nativeOfflineAudioContextConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","nativeOfflineAudioContext","AudioBuffer","length","numberOfChannels","sampleRate","instance","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","createAudioBufferSourceNodeConstructor","audioNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","createNativeAudioBufferSourceNode","wrapEventListener","mergedOptions","nativeAudioBufferSourceNode","audioBufferSourceNodeRenderer","wrappedListener","nativeOnEnded","when","offset","duration","resetInternalStateToPassive","createAudioBufferSourceNodeRendererFactory","connectAudioParam","renderAutomation","renderInputsOfAudioNode","renderedNativeAudioBufferSourceNodes","start","stop","createAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","renderedNativeAudioBufferSourceNode","isAudioBufferSourceNode","isBiquadFilterNode","isConstantSourceNode","isGainNode","isOscillatorNode","isStereoPannerNode","getAudioParamConnections","deactivateActiveAudioNodeInputConnections","trace","audioParams","audioParamConnections","deactivateAudioGraph","isValidLatencyHint","latencyHint","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","channelCount","nativeAudioDestinationNode","audioDestinationNodeRenderer","renderedNativeAudioDestinationNodes","createAudioDestinationNode","renderedNativeAudioDestinationNode","createAudioListenerFactory","createNativeChannelMergerNode","createNativeConstantSourceNode","createNativeScriptProcessorNode","getFirstSample","overwriteAccessors","nativeListener","createFakeAudioParams","buffer","channelMergerNode","isScriptProcessorNodeCreated","lastOrientation","lastPosition","createScriptProcessorNode","scriptProcessorNode","inputBuffer","orientation","positon","createSetOrientation","createSetPosition","createFakeAudioParam","initialValue","setValue","constantSourceNode","get","cancelAndHoldAtTime","args","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setTargetAtTime","setValueAtTime","setValueCurveAtTime","forwardX","forwardY","forwardZ","positionX","positionY","positionZ","upX","upY","upZ","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","element","lmnt","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioParam","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","fakeNativeDestinationAudioNode","deleteActiveInputConnection","activeInputConnections","deleteActiveInputConnectionToAudioParam","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioParam","getNativeAudioParam","testAudioNodeDisconnectMethodSupport","nativeAudioContext","resolve","analyzer","dummy","ones","channelData","event","chnnlDt","sample","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","count","isNativeAudioNode","nativeAudioNodeOrAudioParam","wrapAudioNodeDisconnectMethod","connect","returnValue","connectionsToDestination","connection","destinationOrOutput","filteredConnections","addConnectionToAudioParamOfAudioContext","nativeAudioParam","deleteInputConnectionOfAudioNode","deleteInputConnectionOfAudioParam","deleteInputsOfAudioNode","listener","deleteInputsOfAudioParam","deleteAnyConnection","audioNodeConnectionsOfSource","destinations","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","createIncrementCycleCounter","createInvalidAccessError","decrementCycleCounter","detectCycles","eventTargetConstructor","isNativeAudioContext","isNativeAudioParam","isPassive","createAudioParamFactory","addAudioParamConnections","audioParamAudioNodeStore","audioParamStore","createAudioParamRenderer","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","createSetValueAutomationEvent","createSetValueCurveAutomationEvent","nativeAudioContextConstructor","setValueAtTimeUntilPossible","isAudioParamOfOfflineAudioContext","maxValue","minValue","defaultValue","automationEventList","AutomationEventList","cancelTime","previousLastEvent","currentLastEvent","endTime","currentTime","target","startTime","timeConstant","values","convertedValues","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","theoreticIndex","lowerIndex","upperIndex","timeOfLastSample","automationEvent","ReadOnlyMap","parameters","callback","thisArg","createAudioWorkletNodeConstructor","addUnrenderedAudioWorkletNode","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","getBackupOfflineAudioContext","sanitizeAudioWorkletNodeOptions","setActiveAudioWorkletNodeInputs","testAudioWorkletNodeOptionsClonability","_a","processorConstructor","nativeAudioWorkletNode","audioWorkletNodeRenderer","nm","nativeOnProcessorError","copyFromChannel","parent","channelNumber","bufferOffset","slicedInput","copyToChannel","createNestedArrays","x","y","arrays","array","j","getAudioWorkletProcessor","nodeToProcessorMap","processBuffer","renderedBuffer","outputChannelCount","numberOfInputChannels","numberOfOutputChannels","sum","processedBuffer","audioNodeConnections","audioWorkletProcessor","inputs","prmtrs","k","potentiallyEmptyInputs","activeSourceFlag","outputChannelSplitterNodeOutput","error","createAudioWorkletNodeRendererFactory","connectMultipleOutputs","createNativeChannelSplitterNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","renderNativeOfflineAudioContext","renderedNativeAudioNodes","processedBufferPromise","createAudioNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","outputChannelSplitterNode","outputChannelMergerNodes","outputGainNode","numberOfParameters","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","gainNode","audioBufferSourceNode","outputChannelMergerNode","renderedNativeAudioWorkletNodeOrGainNode","createCacheTestResult","ongoingTests","testResults","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createConnectAudioParam","renderInputsOfAudioParam","createConnectMultipleOutputs","outputAudioNodes","outputAudioNode","createConvertNumberToUnsignedLong","unit32Array","createDecrementCycleCounter","cycleCounters","cycleCounter","nativeDestinationAudioParam","createDeleteActiveInputConnectionToAudioNode","createDeleteUnrenderedAudioWorkletNode","isDelayNode","createDetectCycles","chain","nextLink","mergedCycles","nestedCycles","getOutputAudioNodeAtIndex","createDisconnectMultipleOutputs","createEvaluateSource","reject","head","script","originalOnErrorHandler","removeErrorEventListenerAndRevokeUrl","message","src","lineno","colno","createEventTargetConstructor","_nativeEventTarget","type","wrappedEventListener","createExposeCurrentFrameAndCurrentTime","fn","createFetchSource","response","createGetActiveAudioWorkletNodeInputs","activeAudioWorkletNodeInputsStore","createGetAudioNodeRenderer","createGetAudioNodeTailTime","audioNodeTailTimeStore","createGetAudioParamRenderer","createGetBackupOfflineAudioContext","backupOfflineAudioContextStore","createGetNativeContext","contextStore","createGetOrCreateBackupOfflineAudioContext","createGetUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodeStore","unrenderedAudioWorkletNodes","createIncrementCycleCounterFactory","createIsNativeAudioContext","anything","createIsNativeAudioNode","createIsNativeAudioParam","createIsNativeOfflineAudioContext","createIsSecureContext","createMediaStreamAudioSourceNodeConstructor","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","createMinimalAudioContextConstructor","createUnknownError","minimalBaseAudioContextConstructor","revokeState","resolvePromise","createMinimalBaseAudioContextConstructor","audioDestinationNodeConstructor","createAudioListener","_nativeContext","nativeOnStateChange","testPromiseSupport","uint32Array","createMonitorConnections","whenConnected","whenDisconnected","wasDisconnected","wasConnected","isDisconnected","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","createNativeAudioBufferConstructor","assignNativeAudioNodeAudioParamValue","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","isScheduled","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","createNativeAudioBufferSourceNodeFactory","addSilentConnection","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","createNativeAudioContextConstructor","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","createNativeAudioWorkletNodeConstructor","testClonabilityOfAudioWorkletNodeOptions","audioWorkletNodeOptions","port1","createNativeAudioWorkletNodeFactory","createNativeAudioWorkletNodeFaker","monitorConnections","baseLatency","patchedEventListeners","onprocessorerror","addEventListener","unpatchedEventListener","patchedEventListener","removeEventListener","computeBufferSize","cloneAudioWorkletNodeOptions","port2","data","createAudioWorkletProcessorPromise","clonedAudioWorkletNodeOptions","createAudioWorkletProcessor","audioWorkletProcessorPromise","createNativeAudioWorkletNodeFakerFactory","getActiveAudioWorkletNodeInputs","messageChannel","bufferSize","parameterMap","channelInterpretation","nativeAudioWorkletNodeFaker","_","onmessage","dWrkltPrcssr","disconnectOutputsGraph","activeInputIndexes","outputBuffer","isConnected","disconnectFakeGraph","connectFakeGraph","createNativeChannelMergerNodeFactory","wrapChannelMergerNode","nativeChannelMergerNode","wrapChannelSplitterNode","channelSplitterNode","nativeChannelSplitterNode","createNativeConstantSourceNodeFactory","createNativeConstantSourceNodeFaker","nativeConstantSourceNode","interceptConnections","original","interceptor","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","nativeConstantSourceNodeFaker","mediaStream","audioStreamTracks","a","b","filteredAudioStreamTracks","createNativeOfflineAudioContextConstructor","createRenderAutomation","getAudioParamRenderer","createRenderInputsOfAudioNode","getAudioNodeRenderer","renderedNativeAudioNode","allRenderingPromises","renderingPromises","createRenderInputsOfAudioParam","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","createSetActiveAudioWorkletNodeInputs","createTestAudioBufferConstructorSupport","createTestAudioWorkletProcessorPostMessageSupport","offlineAudioContext","isEmittingMessageEvents","isEmittingProcessorErrorEvents","oscillator","createTestOfflineAudioContextCurrentTimeSupport","createWindow","createWrapAudioBufferCopyChannelMethods","convertNumberToUnsignedLong","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","nullifiedBuffer","createWrapChannelMergerNode","object","property","createGetter","createSetter","prototype","wrapAudioBufferSourceNodeStartMethodOffsetClamping","clampedOffset","disconnectGainNode","isStopped","descriptor","audioBufferConstructor","audioBufferSourceNodeConstructor","isSecureContext","addAudioWorkletModule","mediaStreamAudioSourceNodeConstructor","audioWorkletNodeConstructor","minimalAudioContextConstructor"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165]}