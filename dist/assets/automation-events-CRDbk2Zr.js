const A=(t,n,e)=>({endTime:n,insertTime:e,type:"exponentialRampToValue",value:t}),y=(t,n,e)=>({endTime:n,insertTime:e,type:"linearRampToValue",value:t}),R=(t,n)=>({startTime:n,type:"setValue",value:t}),M=(t,n,e)=>({duration:e,startTime:n,type:"setValueCurve",values:t}),L=(t,n,{startTime:e,target:i,timeConstant:a})=>i+(n-i)*Math.exp((e-t)/a),f=t=>t.type==="exponentialRampToValue",p=t=>t.type==="linearRampToValue",d=t=>f(t)||p(t),E=t=>t.type==="setValue",r=t=>t.type==="setValueCurve",v=(t,n,e,i)=>{const a=t[n];return a===void 0?i:d(a)||E(a)?a.value:r(a)?a.values[a.values.length-1]:L(e,v(t,n-1,a.startTime,i),a)},C=(t,n,e,i,a)=>e===void 0?[i.insertTime,a]:d(e)?[e.endTime,e.value]:E(e)?[e.startTime,e.value]:r(e)?[e.startTime+e.duration,e.values[e.values.length-1]]:[e.startTime,v(t,n-1,e.startTime,a)],_=t=>t.type==="cancelAndHold",V=t=>t.type==="cancelScheduledValues",l=t=>_(t)||V(t)?t.cancelTime:f(t)||p(t)?t.endTime:t.startTime,S=(t,n,e,{endTime:i,value:a})=>e===a?a:0<e&&0<a||e<0&&a<0?e*(a/e)**((t-n)/(i-n)):0,I=(t,n,e,{endTime:i,value:a})=>e+(t-n)/(i-n)*(a-e),H=(t,n)=>{const e=Math.floor(n),i=Math.ceil(n);return e===i?t[e]:(1-(n-e))*t[e]+(1-(i-n))*t[i]},O=(t,{duration:n,startTime:e,values:i})=>{const a=(t-e)/n*(i.length-1);return H(i,a)},T=t=>t.type==="setTarget";class b{constructor(n){this._automationEvents=[],this._currenTime=0,this._defaultValue=n}[Symbol.iterator](){return this._automationEvents[Symbol.iterator]()}add(n){const e=l(n);if(_(n)||V(n)){const i=this._automationEvents.findIndex(s=>V(n)&&r(s)?s.startTime+s.duration>=e:l(s)>=e),a=this._automationEvents[i];if(i!==-1&&(this._automationEvents=this._automationEvents.slice(0,i)),_(n)){const s=this._automationEvents[this._automationEvents.length-1];if(a!==void 0&&d(a)){if(s!==void 0&&T(s))throw new Error("The internal list is malformed.");const u=s===void 0?a.insertTime:r(s)?s.startTime+s.duration:l(s),o=s===void 0?this._defaultValue:r(s)?s.values[s.values.length-1]:s.value,c=f(a)?S(e,u,o,a):I(e,u,o,a),h=f(a)?A(c,e,this._currenTime):y(c,e,this._currenTime);this._automationEvents.push(h)}if(s!==void 0&&T(s)&&this._automationEvents.push(R(this.getValue(e),e)),s!==void 0&&r(s)&&s.startTime+s.duration>e){const u=e-s.startTime,o=(s.values.length-1)/s.duration,c=Math.max(2,1+Math.ceil(u*o)),h=u/(c-1)*o,g=s.values.slice(0,c);if(h<1)for(let m=1;m<c;m+=1){const x=h*m%1;g[m]=s.values[m-1]*(1-x)+s.values[m]*x}this._automationEvents[this._automationEvents.length-1]=M(g,s.startTime,u)}}}else{const i=this._automationEvents.findIndex(u=>l(u)>e),a=i===-1?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[i-1];if(a!==void 0&&r(a)&&l(a)+a.duration>e)return!1;const s=f(n)?A(n.value,n.endTime,this._currenTime):p(n)?y(n.value,e,this._currenTime):n;if(i===-1)this._automationEvents.push(s);else{if(r(n)&&e+n.duration>l(this._automationEvents[i]))return!1;this._automationEvents.splice(i,0,s)}}return!0}flush(n){const e=this._automationEvents.findIndex(i=>l(i)>n);if(e>1){const i=this._automationEvents.slice(e-1),a=i[0];T(a)&&i.unshift(R(v(this._automationEvents,e-2,a.startTime,this._defaultValue),a.startTime)),this._automationEvents=i}}getValue(n){if(this._automationEvents.length===0)return this._defaultValue;const e=this._automationEvents.findIndex(u=>l(u)>n),i=this._automationEvents[e],a=(e===-1?this._automationEvents.length:e)-1,s=this._automationEvents[a];if(s!==void 0&&T(s)&&(i===void 0||!d(i)||i.insertTime>n))return L(n,v(this._automationEvents,a-1,s.startTime,this._defaultValue),s);if(s!==void 0&&E(s)&&(i===void 0||!d(i)))return s.value;if(s!==void 0&&r(s)&&(i===void 0||!d(i)||s.startTime+s.duration>n))return n<s.startTime+s.duration?O(n,s):s.values[s.values.length-1];if(s!==void 0&&d(s)&&(i===void 0||!d(i)))return s.value;if(i!==void 0&&f(i)){const[u,o]=C(this._automationEvents,a,s,i,this._defaultValue);return S(n,u,o,i)}if(i!==void 0&&p(i)){const[u,o]=C(this._automationEvents,a,s,i,this._defaultValue);return I(n,u,o,i)}return this._defaultValue}}const w=t=>({cancelTime:t,type:"cancelAndHold"}),N=t=>({cancelTime:t,type:"cancelScheduledValues"}),P=(t,n)=>({endTime:n,type:"exponentialRampToValue",value:t}),j=(t,n)=>({endTime:n,type:"linearRampToValue",value:t}),k=(t,n,e)=>({startTime:n,target:t,timeConstant:e,type:"setTarget"});export{b as A,R as a,k as b,M as c,j as d,P as e,N as f,w as g};
//# sourceMappingURL=automation-events-CRDbk2Zr.js.map
