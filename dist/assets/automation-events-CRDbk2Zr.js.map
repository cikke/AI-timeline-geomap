{"version":3,"file":"automation-events-CRDbk2Zr.js","sources":["../../node_modules/automation-events/build/es2019/functions/create-extended-exponential-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-extended-linear-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-set-value-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-set-value-curve-automation-event.js","../../node_modules/automation-events/build/es2019/functions/get-target-value-at-time.js","../../node_modules/automation-events/build/es2019/guards/exponential-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/guards/linear-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/guards/any-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/guards/set-value-automation-event.js","../../node_modules/automation-events/build/es2019/guards/set-value-curve-automation-event.js","../../node_modules/automation-events/build/es2019/functions/get-value-of-automation-event-at-index-at-time.js","../../node_modules/automation-events/build/es2019/functions/get-end-time-and-value-of-previous-automation-event.js","../../node_modules/automation-events/build/es2019/guards/cancel-and-hold-automation-event.js","../../node_modules/automation-events/build/es2019/guards/cancel-scheduled-values-automation-event.js","../../node_modules/automation-events/build/es2019/functions/get-event-time.js","../../node_modules/automation-events/build/es2019/functions/get-exponential-ramp-value-at-time.js","../../node_modules/automation-events/build/es2019/functions/get-linear-ramp-value-at-time.js","../../node_modules/automation-events/build/es2019/functions/interpolate-value.js","../../node_modules/automation-events/build/es2019/functions/get-value-curve-value-at-time.js","../../node_modules/automation-events/build/es2019/guards/set-target-automation-event.js","../../node_modules/automation-events/build/es2019/classes/automation-event-list.js","../../node_modules/automation-events/build/es2019/functions/create-cancel-and-hold-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-cancel-scheduled-values-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-exponential-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-linear-ramp-to-value-automation-event.js","../../node_modules/automation-events/build/es2019/functions/create-set-target-automation-event.js"],"sourcesContent":["export const createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {\n    return { endTime, insertTime, type: 'exponentialRampToValue', value };\n};\n//# sourceMappingURL=create-extended-exponential-ramp-to-value-automation-event.js.map","export const createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {\n    return { endTime, insertTime, type: 'linearRampToValue', value };\n};\n//# sourceMappingURL=create-extended-linear-ramp-to-value-automation-event.js.map","export const createSetValueAutomationEvent = (value, startTime) => {\n    return { startTime, type: 'setValue', value };\n};\n//# sourceMappingURL=create-set-value-automation-event.js.map","export const createSetValueCurveAutomationEvent = (values, startTime, duration) => {\n    return { duration, startTime, type: 'setValueCurve', values };\n};\n//# sourceMappingURL=create-set-value-curve-automation-event.js.map","export const getTargetValueAtTime = (time, valueAtStartTime, { startTime, target, timeConstant }) => {\n    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n};\n//# sourceMappingURL=get-target-value-at-time.js.map","export const isExponentialRampToValueAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'exponentialRampToValue';\n};\n//# sourceMappingURL=exponential-ramp-to-value-automation-event.js.map","export const isLinearRampToValueAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'linearRampToValue';\n};\n//# sourceMappingURL=linear-ramp-to-value-automation-event.js.map","import { isExponentialRampToValueAutomationEvent } from './exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from './linear-ramp-to-value-automation-event';\nexport const isAnyRampToValueAutomationEvent = (automationEvent) => {\n    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n};\n//# sourceMappingURL=any-ramp-to-value-automation-event.js.map","export const isSetValueAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'setValue';\n};\n//# sourceMappingURL=set-value-automation-event.js.map","export const isSetValueCurveAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'setValueCurve';\n};\n//# sourceMappingURL=set-value-curve-automation-event.js.map","import { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport const getValueOfAutomationEventAtIndexAtTime = (automationEvents, index, time, defaultValue) => {\n    const automationEvent = automationEvents[index];\n    return automationEvent === undefined\n        ? defaultValue\n        : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent)\n            ? automationEvent.value\n            : isSetValueCurveAutomationEvent(automationEvent)\n                ? automationEvent.values[automationEvent.values.length - 1]\n                : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n};\n//# sourceMappingURL=get-value-of-automation-event-at-index-at-time.js.map","import { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport const getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) => {\n    return currentAutomationEvent === undefined\n        ? [nextAutomationEvent.insertTime, defaultValue]\n        : isAnyRampToValueAutomationEvent(currentAutomationEvent)\n            ? [currentAutomationEvent.endTime, currentAutomationEvent.value]\n            : isSetValueAutomationEvent(currentAutomationEvent)\n                ? [currentAutomationEvent.startTime, currentAutomationEvent.value]\n                : isSetValueCurveAutomationEvent(currentAutomationEvent)\n                    ? [\n                        currentAutomationEvent.startTime + currentAutomationEvent.duration,\n                        currentAutomationEvent.values[currentAutomationEvent.values.length - 1]\n                    ]\n                    : [\n                        currentAutomationEvent.startTime,\n                        getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)\n                    ];\n};\n//# sourceMappingURL=get-end-time-and-value-of-previous-automation-event.js.map","export const isCancelAndHoldAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'cancelAndHold';\n};\n//# sourceMappingURL=cancel-and-hold-automation-event.js.map","export const isCancelScheduledValuesAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'cancelScheduledValues';\n};\n//# sourceMappingURL=cancel-scheduled-values-automation-event.js.map","import { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nexport const getEventTime = (automationEvent) => {\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n    }\n    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n    }\n    return automationEvent.startTime;\n};\n//# sourceMappingURL=get-event-time.js.map","export const getExponentialRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {\n    if (valueAtStartTime === value) {\n        return value;\n    }\n    if ((0 < valueAtStartTime && 0 < value) || (valueAtStartTime < 0 && value < 0)) {\n        return valueAtStartTime * (value / valueAtStartTime) ** ((time - startTime) / (endTime - startTime));\n    }\n    return 0;\n};\n//# sourceMappingURL=get-exponential-ramp-value-at-time.js.map","export const getLinearRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {\n    return valueAtStartTime + ((time - startTime) / (endTime - startTime)) * (value - valueAtStartTime);\n};\n//# sourceMappingURL=get-linear-ramp-value-at-time.js.map","export const interpolateValue = (values, theoreticIndex) => {\n    const lowerIndex = Math.floor(theoreticIndex);\n    const upperIndex = Math.ceil(theoreticIndex);\n    if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n    }\n    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n};\n//# sourceMappingURL=interpolate-value.js.map","import { interpolateValue } from './interpolate-value';\nexport const getValueCurveValueAtTime = (time, { duration, startTime, values }) => {\n    const theoreticIndex = ((time - startTime) / duration) * (values.length - 1);\n    return interpolateValue(values, theoreticIndex);\n};\n//# sourceMappingURL=get-value-curve-value-at-time.js.map","export const isSetTargetAutomationEvent = (automationEvent) => {\n    return automationEvent.type === 'setTarget';\n};\n//# sourceMappingURL=set-target-automation-event.js.map","import { createExtendedExponentialRampToValueAutomationEvent } from '../functions/create-extended-exponential-ramp-to-value-automation-event';\nimport { createExtendedLinearRampToValueAutomationEvent } from '../functions/create-extended-linear-ramp-to-value-automation-event';\nimport { createSetValueAutomationEvent } from '../functions/create-set-value-automation-event';\nimport { createSetValueCurveAutomationEvent } from '../functions/create-set-value-curve-automation-event';\nimport { getEndTimeAndValueOfPreviousAutomationEvent } from '../functions/get-end-time-and-value-of-previous-automation-event';\nimport { getEventTime } from '../functions/get-event-time';\nimport { getExponentialRampValueAtTime } from '../functions/get-exponential-ramp-value-at-time';\nimport { getLinearRampValueAtTime } from '../functions/get-linear-ramp-value-at-time';\nimport { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { getValueCurveValueAtTime } from '../functions/get-value-curve-value-at-time';\nimport { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nimport { isSetTargetAutomationEvent } from '../guards/set-target-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nexport class AutomationEventList {\n    constructor(defaultValue) {\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n    }\n    [Symbol.iterator]() {\n        return this._automationEvents[Symbol.iterator]();\n    }\n    add(automationEvent) {\n        const eventTime = getEventTime(automationEvent);\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => {\n                if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                    return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n                }\n                return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            const removedAutomationEvent = this._automationEvents[index];\n            if (index !== -1) {\n                this._automationEvents = this._automationEvents.slice(0, index);\n            }\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n                const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n                if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                    if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                        throw new Error('The internal list is malformed.');\n                    }\n                    const startTime = lastAutomationEvent === undefined\n                        ? removedAutomationEvent.insertTime\n                        : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.startTime + lastAutomationEvent.duration\n                            : getEventTime(lastAutomationEvent);\n                    const startValue = lastAutomationEvent === undefined\n                        ? this._defaultValue\n                        : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1]\n                            : lastAutomationEvent.value;\n                    const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent)\n                        : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                    const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime)\n                        : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n                    this._automationEvents.push(truncatedAutomationEvent);\n                }\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                    this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n                }\n                if (lastAutomationEvent !== undefined &&\n                    isSetValueCurveAutomationEvent(lastAutomationEvent) &&\n                    lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                    const duration = eventTime - lastAutomationEvent.startTime;\n                    const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                    const length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                    const fraction = (duration / (length - 1)) * ratio;\n                    const values = lastAutomationEvent.values.slice(0, length);\n                    if (fraction < 1) {\n                        for (let i = 1; i < length; i += 1) {\n                            const factor = (fraction * i) % 1;\n                            values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                        }\n                    }\n                    this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n                }\n            }\n        }\n        else {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);\n            const previousAutomationEvent = index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];\n            if (previousAutomationEvent !== undefined &&\n                isSetValueCurveAutomationEvent(previousAutomationEvent) &&\n                getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n                return false;\n            }\n            const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent)\n                ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime)\n                : isLinearRampToValueAutomationEvent(automationEvent)\n                    ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime)\n                    : automationEvent;\n            if (index === -1) {\n                this._automationEvents.push(persistentAutomationEvent);\n            }\n            else {\n                if (isSetValueCurveAutomationEvent(automationEvent) &&\n                    eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])) {\n                    return false;\n                }\n                this._automationEvents.splice(index, 0, persistentAutomationEvent);\n            }\n        }\n        return true;\n    }\n    flush(time) {\n        const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);\n        if (index > 1) {\n            const remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            const firstRemainingAutomationEvent = remainingAutomationEvents[0];\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n                remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n            this._automationEvents = remainingAutomationEvents;\n        }\n    }\n    getValue(time) {\n        if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n        }\n        const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);\n        const nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n        const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n        const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n        if (currentAutomationEvent !== undefined &&\n            isSetTargetAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n        }\n        if (currentAutomationEvent !== undefined &&\n            isSetValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n        }\n        if (currentAutomationEvent !== undefined &&\n            isSetValueCurveAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n                return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n        if (currentAutomationEvent !== undefined &&\n            isAnyRampToValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n        }\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n            return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n        return this._defaultValue;\n    }\n}\n//# sourceMappingURL=automation-event-list.js.map","export const createCancelAndHoldAutomationEvent = (cancelTime) => {\n    return { cancelTime, type: 'cancelAndHold' };\n};\n//# sourceMappingURL=create-cancel-and-hold-automation-event.js.map","export const createCancelScheduledValuesAutomationEvent = (cancelTime) => {\n    return { cancelTime, type: 'cancelScheduledValues' };\n};\n//# sourceMappingURL=create-cancel-scheduled-values-automation-event.js.map","export const createExponentialRampToValueAutomationEvent = (value, endTime) => {\n    return { endTime, type: 'exponentialRampToValue', value };\n};\n//# sourceMappingURL=create-exponential-ramp-to-value-automation-event.js.map","export const createLinearRampToValueAutomationEvent = (value, endTime) => {\n    return { endTime, type: 'linearRampToValue', value };\n};\n//# sourceMappingURL=create-linear-ramp-to-value-automation-event.js.map","export const createSetTargetAutomationEvent = (target, startTime, timeConstant) => {\n    return { startTime, target, timeConstant, type: 'setTarget' };\n};\n//# sourceMappingURL=create-set-target-automation-event.js.map"],"names":["createExtendedExponentialRampToValueAutomationEvent","value","endTime","insertTime","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","target","timeConstant","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","getExponentialRampValueAtTime","getLinearRampValueAtTime","interpolateValue","theoreticIndex","lowerIndex","upperIndex","getValueCurveValueAtTime","isSetTargetAutomationEvent","AutomationEventList","eventTime","removedAutomationEvent","lastAutomationEvent","startValue","truncatedAutomationEvent","ratio","length","fraction","i","factor","previousAutomationEvent","persistentAutomationEvent","remainingAutomationEvents","firstRemainingAutomationEvent","indexOfNextEvent","indexOfCurrentEvent","createCancelAndHoldAutomationEvent","cancelTime","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent"],"mappings":"AAAO,MAAMA,EAAsD,CAACC,EAAOC,EAASC,KACzE,CAAE,QAAAD,EAAS,WAAAC,EAAY,KAAM,yBAA0B,MAAAF,CAAK,GCD1DG,EAAiD,CAACH,EAAOC,EAASC,KACpE,CAAE,QAAAD,EAAS,WAAAC,EAAY,KAAM,oBAAqB,MAAAF,CAAK,GCDrDI,EAAgC,CAACJ,EAAOK,KAC1C,CAAE,UAAAA,EAAW,KAAM,WAAY,MAAAL,CAAK,GCDlCM,EAAqC,CAACC,EAAQF,EAAWG,KAC3D,CAAE,SAAAA,EAAU,UAAAH,EAAW,KAAM,gBAAiB,OAAAE,CAAM,GCDlDE,EAAuB,CAACC,EAAMC,EAAkB,CAAE,UAAAN,EAAW,OAAAO,EAAQ,aAAAC,KACvED,GAAUD,EAAmBC,GAAU,KAAK,KAAKP,EAAYK,GAAQG,CAAY,ECD/EC,EAA2CC,GAC7CA,EAAgB,OAAS,yBCDvBC,EAAsCD,GACxCA,EAAgB,OAAS,oBCCvBE,EAAmCF,GACrCD,EAAwCC,CAAe,GAAKC,EAAmCD,CAAe,ECH5GG,EAA6BH,GAC/BA,EAAgB,OAAS,WCDvBI,EAAkCJ,GACpCA,EAAgB,OAAS,gBCGvBK,EAAyC,CAACC,EAAkBC,EAAOZ,EAAMa,IAAiB,CACnG,MAAMR,EAAkBM,EAAiBC,CAAK,EAC9C,OAAOP,IAAoB,OACrBQ,EACAN,EAAgCF,CAAe,GAAKG,EAA0BH,CAAe,EACzFA,EAAgB,MAChBI,EAA+BJ,CAAe,EAC1CA,EAAgB,OAAOA,EAAgB,OAAO,OAAS,CAAC,EACxDN,EAAqBC,EAAMU,EAAuCC,EAAkBC,EAAQ,EAAGP,EAAgB,UAAWQ,CAAY,EAAGR,CAAe,CAC1K,ECTaS,EAA8C,CAACH,EAAkBC,EAAOG,EAAwBC,EAAqBH,IACvHE,IAA2B,OAC5B,CAACC,EAAoB,WAAYH,CAAY,EAC7CN,EAAgCQ,CAAsB,EAClD,CAACA,EAAuB,QAASA,EAAuB,KAAK,EAC7DP,EAA0BO,CAAsB,EAC5C,CAACA,EAAuB,UAAWA,EAAuB,KAAK,EAC/DN,EAA+BM,CAAsB,EACjD,CACEA,EAAuB,UAAYA,EAAuB,SAC1DA,EAAuB,OAAOA,EAAuB,OAAO,OAAS,CAAC,CACzE,EACC,CACEA,EAAuB,UACvBL,EAAuCC,EAAkBC,EAAQ,EAAGG,EAAuB,UAAWF,CAAY,CAC1I,ECnBaI,EAAkCZ,GACpCA,EAAgB,OAAS,gBCDvBa,EAA0Cb,GAC5CA,EAAgB,OAAS,wBCGvBc,EAAgBd,GACrBY,EAA+BZ,CAAe,GAAKa,EAAuCb,CAAe,EAClGA,EAAgB,WAEvBD,EAAwCC,CAAe,GAAKC,EAAmCD,CAAe,EACvGA,EAAgB,QAEpBA,EAAgB,UCXde,EAAgC,CAACpB,EAAML,EAAWM,EAAkB,CAAE,QAAAV,EAAS,MAAAD,KACpFW,IAAqBX,EACdA,EAEN,EAAIW,GAAoB,EAAIX,GAAWW,EAAmB,GAAKX,EAAQ,EACjEW,GAAoBX,EAAQW,MAAuBD,EAAOL,IAAcJ,EAAUI,IAEtF,ECPE0B,EAA2B,CAACrB,EAAML,EAAWM,EAAkB,CAAE,QAAAV,EAAS,MAAAD,KAC5EW,GAAqBD,EAAOL,IAAcJ,EAAUI,IAAeL,EAAQW,GCDzEqB,EAAmB,CAACzB,EAAQ0B,IAAmB,CACxD,MAAMC,EAAa,KAAK,MAAMD,CAAc,EACtCE,EAAa,KAAK,KAAKF,CAAc,EAC3C,OAAIC,IAAeC,EACR5B,EAAO2B,CAAU,GAEpB,GAAKD,EAAiBC,IAAe3B,EAAO2B,CAAU,GAAK,GAAKC,EAAaF,IAAmB1B,EAAO4B,CAAU,CAC7H,ECNaC,EAA2B,CAAC1B,EAAM,CAAE,SAAAF,EAAU,UAAAH,EAAW,OAAAE,CAAM,IAAO,CAC/E,MAAM0B,GAAmBvB,EAAOL,GAAaG,GAAaD,EAAO,OAAS,GAC1E,OAAOyB,EAAiBzB,EAAQ0B,CAAc,CAClD,ECJaI,EAA8BtB,GAChCA,EAAgB,OAAS,YCkB7B,MAAMuB,CAAoB,CAC7B,YAAYf,EAAc,CACtB,KAAK,kBAAoB,GACzB,KAAK,YAAc,EACnB,KAAK,cAAgBA,CACxB,CACD,CAAC,OAAO,QAAQ,GAAI,CAChB,OAAO,KAAK,kBAAkB,OAAO,QAAQ,EAAC,CACjD,CACD,IAAIR,EAAiB,CACjB,MAAMwB,EAAYV,EAAad,CAAe,EAC9C,GAAIY,EAA+BZ,CAAe,GAAKa,EAAuCb,CAAe,EAAG,CAC5G,MAAMO,EAAQ,KAAK,kBAAkB,UAAWG,GACxCG,EAAuCb,CAAe,GAAKI,EAA+BM,CAAsB,EACzGA,EAAuB,UAAYA,EAAuB,UAAYc,EAE1EV,EAAaJ,CAAsB,GAAKc,CAClD,EACKC,EAAyB,KAAK,kBAAkBlB,CAAK,EAI3D,GAHIA,IAAU,KACV,KAAK,kBAAoB,KAAK,kBAAkB,MAAM,EAAGA,CAAK,GAE9DK,EAA+BZ,CAAe,EAAG,CACjD,MAAM0B,EAAsB,KAAK,kBAAkB,KAAK,kBAAkB,OAAS,CAAC,EACpF,GAAID,IAA2B,QAAavB,EAAgCuB,CAAsB,EAAG,CACjG,GAAIC,IAAwB,QAAaJ,EAA2BI,CAAmB,EACnF,MAAM,IAAI,MAAM,iCAAiC,EAErD,MAAMpC,EAAYoC,IAAwB,OACpCD,EAAuB,WACvBrB,EAA+BsB,CAAmB,EAC9CA,EAAoB,UAAYA,EAAoB,SACpDZ,EAAaY,CAAmB,EACpCC,EAAaD,IAAwB,OACrC,KAAK,cACLtB,EAA+BsB,CAAmB,EAC9CA,EAAoB,OAAOA,EAAoB,OAAO,OAAS,CAAC,EAChEA,EAAoB,MACxBzC,EAAQc,EAAwC0B,CAAsB,EACtEV,EAA8BS,EAAWlC,EAAWqC,EAAYF,CAAsB,EACtFT,EAAyBQ,EAAWlC,EAAWqC,EAAYF,CAAsB,EACjFG,EAA2B7B,EAAwC0B,CAAsB,EACzFzC,EAAoDC,EAAOuC,EAAW,KAAK,WAAW,EACtFpC,EAA+CH,EAAOuC,EAAW,KAAK,WAAW,EACvF,KAAK,kBAAkB,KAAKI,CAAwB,CACvD,CAID,GAHIF,IAAwB,QAAaJ,EAA2BI,CAAmB,GACnF,KAAK,kBAAkB,KAAKrC,EAA8B,KAAK,SAASmC,CAAS,EAAGA,CAAS,CAAC,EAE9FE,IAAwB,QACxBtB,EAA+BsB,CAAmB,GAClDA,EAAoB,UAAYA,EAAoB,SAAWF,EAAW,CAC1E,MAAM/B,EAAW+B,EAAYE,EAAoB,UAC3CG,GAASH,EAAoB,OAAO,OAAS,GAAKA,EAAoB,SACtEI,EAAS,KAAK,IAAI,EAAG,EAAI,KAAK,KAAKrC,EAAWoC,CAAK,CAAC,EACpDE,EAAYtC,GAAYqC,EAAS,GAAMD,EACvCrC,EAASkC,EAAoB,OAAO,MAAM,EAAGI,CAAM,EACzD,GAAIC,EAAW,EACX,QAASC,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAAG,CAChC,MAAMC,EAAUF,EAAWC,EAAK,EAChCxC,EAAOwC,CAAC,EAAIN,EAAoB,OAAOM,EAAI,CAAC,GAAK,EAAIC,GAAUP,EAAoB,OAAOM,CAAC,EAAIC,CAClG,CAEL,KAAK,kBAAkB,KAAK,kBAAkB,OAAS,CAAC,EAAI1C,EAAmCC,EAAQkC,EAAoB,UAAWjC,CAAQ,CACjJ,CACJ,CACJ,KACI,CACD,MAAMc,EAAQ,KAAK,kBAAkB,UAAWG,GAA2BI,EAAaJ,CAAsB,EAAIc,CAAS,EACrHU,EAA0B3B,IAAU,GAAK,KAAK,kBAAkB,KAAK,kBAAkB,OAAS,CAAC,EAAI,KAAK,kBAAkBA,EAAQ,CAAC,EAC3I,GAAI2B,IAA4B,QAC5B9B,EAA+B8B,CAAuB,GACtDpB,EAAaoB,CAAuB,EAAIA,EAAwB,SAAWV,EAC3E,MAAO,GAEX,MAAMW,EAA4BpC,EAAwCC,CAAe,EACnFhB,EAAoDgB,EAAgB,MAAOA,EAAgB,QAAS,KAAK,WAAW,EACpHC,EAAmCD,CAAe,EAC9CZ,EAA+CY,EAAgB,MAAOwB,EAAW,KAAK,WAAW,EACjGxB,EACV,GAAIO,IAAU,GACV,KAAK,kBAAkB,KAAK4B,CAAyB,MAEpD,CACD,GAAI/B,EAA+BJ,CAAe,GAC9CwB,EAAYxB,EAAgB,SAAWc,EAAa,KAAK,kBAAkBP,CAAK,CAAC,EACjF,MAAO,GAEX,KAAK,kBAAkB,OAAOA,EAAO,EAAG4B,CAAyB,CACpE,CACJ,CACD,MAAO,EACV,CACD,MAAMxC,EAAM,CACR,MAAMY,EAAQ,KAAK,kBAAkB,UAAWG,GAA2BI,EAAaJ,CAAsB,EAAIf,CAAI,EACtH,GAAIY,EAAQ,EAAG,CACX,MAAM6B,EAA4B,KAAK,kBAAkB,MAAM7B,EAAQ,CAAC,EAClE8B,EAAgCD,EAA0B,CAAC,EAC7Dd,EAA2Be,CAA6B,GACxDD,EAA0B,QAAQ/C,EAA8BgB,EAAuC,KAAK,kBAAmBE,EAAQ,EAAG8B,EAA8B,UAAW,KAAK,aAAa,EAAGA,EAA8B,SAAS,CAAC,EAEpP,KAAK,kBAAoBD,CAC5B,CACJ,CACD,SAASzC,EAAM,CACX,GAAI,KAAK,kBAAkB,SAAW,EAClC,OAAO,KAAK,cAEhB,MAAM2C,EAAmB,KAAK,kBAAkB,UAAWtC,GAAoBc,EAAad,CAAe,EAAIL,CAAI,EAC7GgB,EAAsB,KAAK,kBAAkB2B,CAAgB,EAC7DC,GAAuBD,IAAqB,GAAK,KAAK,kBAAkB,OAASA,GAAoB,EACrG5B,EAAyB,KAAK,kBAAkB6B,CAAmB,EACzE,GAAI7B,IAA2B,QAC3BY,EAA2BZ,CAAsB,IAChDC,IAAwB,QACrB,CAACT,EAAgCS,CAAmB,GACpDA,EAAoB,WAAahB,GACrC,OAAOD,EAAqBC,EAAMU,EAAuC,KAAK,kBAAmBkC,EAAsB,EAAG7B,EAAuB,UAAW,KAAK,aAAa,EAAGA,CAAsB,EAE3M,GAAIA,IAA2B,QAC3BP,EAA0BO,CAAsB,IAC/CC,IAAwB,QAAa,CAACT,EAAgCS,CAAmB,GAC1F,OAAOD,EAAuB,MAElC,GAAIA,IAA2B,QAC3BN,EAA+BM,CAAsB,IACpDC,IAAwB,QACrB,CAACT,EAAgCS,CAAmB,GACpDD,EAAuB,UAAYA,EAAuB,SAAWf,GACzE,OAAIA,EAAOe,EAAuB,UAAYA,EAAuB,SAC1DW,EAAyB1B,EAAMe,CAAsB,EAEzDA,EAAuB,OAAOA,EAAuB,OAAO,OAAS,CAAC,EAEjF,GAAIA,IAA2B,QAC3BR,EAAgCQ,CAAsB,IACrDC,IAAwB,QAAa,CAACT,EAAgCS,CAAmB,GAC1F,OAAOD,EAAuB,MAElC,GAAIC,IAAwB,QAAaZ,EAAwCY,CAAmB,EAAG,CACnG,KAAM,CAACrB,EAAWL,CAAK,EAAIwB,EAA4C,KAAK,kBAAmB8B,EAAqB7B,EAAwBC,EAAqB,KAAK,aAAa,EACnL,OAAOI,EAA8BpB,EAAML,EAAWL,EAAO0B,CAAmB,CACnF,CACD,GAAIA,IAAwB,QAAaV,EAAmCU,CAAmB,EAAG,CAC9F,KAAM,CAACrB,EAAWL,CAAK,EAAIwB,EAA4C,KAAK,kBAAmB8B,EAAqB7B,EAAwBC,EAAqB,KAAK,aAAa,EACnL,OAAOK,EAAyBrB,EAAML,EAAWL,EAAO0B,CAAmB,CAC9E,CACD,OAAO,KAAK,aACf,CACL,CCxKY,MAAC6B,EAAsCC,IACxC,CAAE,WAAAA,EAAY,KAAM,kBCDlBC,EAA8CD,IAChD,CAAE,WAAAA,EAAY,KAAM,0BCDlBE,EAA8C,CAAC1D,EAAOC,KACxD,CAAE,QAAAA,EAAS,KAAM,yBAA0B,MAAAD,CAAK,GCD9C2D,EAAyC,CAAC3D,EAAOC,KACnD,CAAE,QAAAA,EAAS,KAAM,oBAAqB,MAAAD,CAAK,GCDzC4D,EAAiC,CAAChD,EAAQP,EAAWQ,KACvD,CAAE,UAAAR,EAAW,OAAAO,EAAQ,aAAAC,EAAc,KAAM,WAAW","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}