import{A as un,c as ln,a as fn,b as dn,d as hn,e as pn,f as mn,g as Cn}from"./automation-events-CRDbk2Zr.js";const An=()=>new DOMException("","AbortError"),wn=e=>(t,n,[r,o,s],c)=>{e(t[o],[n,r,s],a=>a[0]===n&&a[1]===r,c)},yn=e=>(t,n,r)=>{const o=[];for(let s=0;s<r.numberOfInputs;s+=1)o.push(new Set);e.set(t,{activeInputs:o,outputs:new Set,passiveInputs:new WeakMap,renderer:n})},gn=e=>(t,n)=>{e.set(t,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:n})},de=new WeakSet,yt=new WeakMap,gt=new WeakMap,bt=new WeakMap,Nt=new WeakMap,Ot=new WeakMap,vt=new WeakMap,je=new WeakMap,Ge=new WeakMap,Ue=new WeakMap,Mt={construct(){return Mt}},bn=e=>{try{const t=new Proxy(e,Mt);new t}catch{return!1}return!0},ut=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,lt=(e,t)=>{const n=[];let r=e.replace(/^[\s]+/,""),o=r.match(ut);for(;o!==null;){const s=o[1].slice(1,-1),c=o[0].replace(/([\s]+)?;?$/,"").replace(s,new URL(s,t).toString());n.push(c),r=r.slice(o[0].length).replace(/^[\s]+/,""),o=r.match(ut)}return[n.join(";"),r]},ft=e=>{if(e!==void 0&&!Array.isArray(e))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},dt=e=>{if(!bn(e))throw new TypeError("The given value for processorCtor should be a constructor.");if(e.prototype===null||typeof e.prototype!="object")throw new TypeError("The given value for processorCtor should have a prototype.")},Nn=(e,t,n,r,o,s,c,a,i,u,h,l,N)=>{let p=0;return(C,f,m={credentials:"omit"})=>{const d=h.get(C);if(d!==void 0&&d.has(f))return Promise.resolve();const v=u.get(C);if(v!==void 0){const y=v.get(f);if(y!==void 0)return y}const A=s(C),M=A.audioWorklet===void 0?o(f).then(([y,b])=>{const[w,g]=lt(y,b),k=`${w};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${g}
})})(window,'_AWGS')`;return n(k)}).then(()=>{const y=N._AWGS.pop();if(y===void 0)throw new SyntaxError;r(A.currentTime,A.sampleRate,()=>y(class{},void 0,(b,w)=>{if(b.trim()==="")throw t();const g=Ge.get(A);if(g!==void 0){if(g.has(b))throw t();dt(w),ft(w.parameterDescriptors),g.set(b,w)}else dt(w),ft(w.parameterDescriptors),Ge.set(A,new Map([[b,w]]))},A.sampleRate,void 0,void 0))}):Promise.all([o(f),Promise.resolve(e(l,l))]).then(([[y,b],w])=>{const g=p+1;p=g;const[k,P]=lt(y,b),x=`${k};((AudioWorkletProcessor,registerProcessor)=>{${P}
})(${w?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${w?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${w?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${g}',class extends AudioWorkletProcessor{process(){return !1}})`,L=new Blob([x],{type:"application/javascript; charset=utf-8"}),I=URL.createObjectURL(L);return A.audioWorklet.addModule(I,m).then(()=>{if(a(A))return A;const D=c(A);return D.audioWorklet.addModule(I,m).then(()=>D)}).then(D=>{if(i===null)throw new SyntaxError;try{new i(D,`__sac${g}`)}catch{throw new SyntaxError}}).finally(()=>URL.revokeObjectURL(I))});return v===void 0?u.set(C,new Map([[f,M]])):v.set(f,M),M.then(()=>{const y=h.get(C);y===void 0?h.set(C,new Set([f])):y.add(f)}).finally(()=>{const y=u.get(C);y!==void 0&&y.delete(f)}),M}},K=(e,t)=>{const n=e.get(t);if(n===void 0)throw new Error("A value with the given key could not be found.");return n},Ie=(e,t)=>{const n=Array.from(e).filter(t);if(n.length>1)throw Error("More than one element was found.");if(n.length===0)throw Error("No element was found.");const[r]=n;return e.delete(r),r},Et=(e,t,n,r)=>{const o=K(e,t),s=Ie(o,c=>c[0]===n&&c[1]===r);return o.size===0&&e.delete(t),s},we=e=>K(vt,e),Me=e=>{if(de.has(e))throw new Error("The AudioNode is already stored.");de.add(e),we(e).forEach(t=>t(!0))},_t=e=>"port"in e,qe=e=>{if(!de.has(e))throw new Error("The AudioNode is not stored.");de.delete(e),we(e).forEach(t=>t(!1))},$e=(e,t)=>{!_t(e)&&t.every(n=>n.size===0)&&qe(e)},On=(e,t,n,r,o,s,c,a,i,u,h,l,N)=>{const p=new WeakMap;return(C,f,m,d,v)=>{const{activeInputs:A,passiveInputs:M}=s(f),{outputs:y}=s(C),b=a(C),w=g=>{const k=i(f),P=i(C);if(g){const _=Et(M,C,m,d);e(A,C,_,!1),!v&&!l(C)&&n(P,k,m,d),N(f)&&Me(f)}else{const _=r(A,C,m,d);t(M,d,_,!1),!v&&!l(C)&&o(P,k,m,d);const W=c(f);if(W===0)h(f)&&$e(f,A);else{const V=p.get(f);V!==void 0&&clearTimeout(V),p.set(f,setTimeout(()=>{h(f)&&$e(f,A)},W*1e3))}}};return u(y,[f,m,d],g=>g[0]===f&&g[1]===m&&g[2]===d,!0)?(b.add(w),h(C)?e(A,C,[m,d,w],!0):t(M,d,[C,m,w],!0),!0):!1}},vn=e=>(t,n,[r,o,s],c)=>{const a=t.get(r);a===void 0?t.set(r,new Set([[o,n,s]])):e(a,[o,n,s],i=>i[0]===o&&i[1]===n,c)},Mn=e=>(t,n)=>{const r=e(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});n.connect(r).connect(t.destination);const o=()=>{n.removeEventListener("ended",o),n.disconnect(r),r.disconnect()};n.addEventListener("ended",o)},En=e=>(t,n)=>{e(t).add(n)},Tt=(e,t)=>e.context===t,ht=e=>{try{e.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},ce=()=>new DOMException("","IndexSizeError"),_n=e=>{e.getChannelData=(t=>n=>{try{return t.call(e,n)}catch(r){throw r.code===12?ce():r}})(e.getChannelData)},Tn={numberOfChannels:1},kn=(e,t,n,r,o,s,c,a)=>{let i=null;return class kt{constructor(h){if(o===null)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:l,numberOfChannels:N,sampleRate:p}={...Tn,...h};i===null&&(i=new o(1,1,44100));const C=r!==null&&t(s,s)?new r({length:l,numberOfChannels:N,sampleRate:p}):i.createBuffer(N,l,p);if(C.numberOfChannels===0)throw n();return typeof C.copyFromChannel!="function"?(c(C),_n(C)):t(ht,()=>ht(C))||a(C),e.add(C),C}static[Symbol.hasInstance](h){return h!==null&&typeof h=="object"&&Object.getPrototypeOf(h)===kt.prototype||e.has(h)}}},Se=-34028234663852886e22,Ze=-Se,re=e=>de.has(e),In={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},Sn=(e,t,n,r,o,s,c,a)=>class extends e{constructor(u,h){const l=s(u),N={...In,...h},p=o(l,N),C=c(l),f=C?t():null;super(u,!1,p,f),this._audioBufferSourceNodeRenderer=f,this._isBufferNullified=!1,this._isBufferSet=N.buffer!==null,this._nativeAudioBufferSourceNode=p,this._onended=null,this._playbackRate=n(this,C,p.playbackRate,Ze,Se)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(u){if(this._nativeAudioBufferSourceNode.buffer=u,u!==null){if(this._isBufferSet)throw r();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(u){this._nativeAudioBufferSourceNode.loop=u}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(u){this._nativeAudioBufferSourceNode.loopEnd=u}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(u){this._nativeAudioBufferSourceNode.loopStart=u}get onended(){return this._onended}set onended(u){const h=typeof u=="function"?a(this,u):null;this._nativeAudioBufferSourceNode.onended=h;const l=this._nativeAudioBufferSourceNode.onended;this._onended=l!==null&&l===h?u:l}get playbackRate(){return this._playbackRate}start(u=0,h=0,l){if(this._nativeAudioBufferSourceNode.start(u,h,l),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.start=l===void 0?[u,h]:[u,h,l]),this.context.state!=="closed"){Me(this);const N=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",N),re(this)&&qe(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",N)}}stop(u=0){this._nativeAudioBufferSourceNode.stop(u),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.stop=u)}},Pn=(e,t,n,r,o)=>()=>{const s=new WeakMap;let c=null,a=null;const i=async(u,h)=>{let l=n(u);const N=Tt(l,h);if(!N){const p={buffer:l.buffer,channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,loop:l.loop,loopEnd:l.loopEnd,loopStart:l.loopStart,playbackRate:l.playbackRate.value};l=t(h,p),c!==null&&l.start(...c),a!==null&&l.stop(a)}return s.set(h,l),N?await e(h,u.playbackRate,l.playbackRate):await r(h,u.playbackRate,l.playbackRate),await o(u,h,l),l};return{set start(u){c=u},set stop(u){a=u},render(u,h){const l=s.get(h);return l!==void 0?Promise.resolve(l):i(u,h)}}},Rn=e=>"playbackRate"in e,Wn=e=>"frequency"in e&&"gain"in e,Dn=e=>"offset"in e,Ln=e=>!("frequency"in e)&&"gain"in e,Bn=e=>"detune"in e&&"frequency"in e&&!("gain"in e),Vn=e=>"pan"in e,z=e=>K(yt,e),ye=e=>K(bt,e),Xe=(e,t)=>{const{activeInputs:n}=z(e);n.forEach(o=>o.forEach(([s])=>{t.includes(e)||Xe(s,[...t,e])}));const r=Rn(e)?[e.playbackRate]:_t(e)?Array.from(e.parameters.values()):Wn(e)?[e.Q,e.detune,e.frequency,e.gain]:Dn(e)?[e.offset]:Ln(e)?[e.gain]:Bn(e)?[e.detune,e.frequency]:Vn(e)?[e.pan]:[];for(const o of r){const s=ye(o);s!==void 0&&s.activeInputs.forEach(([c])=>Xe(c,t))}re(e)&&qe(e)},xn=e=>{Xe(e.destination,[])},Fn=e=>e===void 0||typeof e=="number"||typeof e=="string"&&(e==="balanced"||e==="interactive"||e==="playback"),jn=(e,t,n,r,o,s,c,a)=>class extends e{constructor(u,h){const l=s(u),N=c(l),p=o(l,h,N),C=N?t(a):null;super(u,!1,p,C),this._isNodeOfNativeOfflineAudioContext=N,this._nativeAudioDestinationNode=p}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(u){if(this._isNodeOfNativeOfflineAudioContext)throw r();if(u>this._nativeAudioDestinationNode.maxChannelCount)throw n();this._nativeAudioDestinationNode.channelCount=u}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(u){if(this._isNodeOfNativeOfflineAudioContext)throw r();this._nativeAudioDestinationNode.channelCountMode=u}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}},Gn=e=>{const t=new WeakMap,n=async(r,o)=>{const s=o.destination;return t.set(o,s),await e(r,o,s),s};return{render(r,o){const s=t.get(o);return s!==void 0?Promise.resolve(s):n(r,o)}}},Un=(e,t,n,r,o,s,c,a)=>(i,u)=>{const h=u.listener,l=()=>{const y=new Float32Array(1),b=t(u,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),w=c(u);let g=!1,k=[0,0,-1,0,1,0],P=[0,0,0];const _=()=>{if(g)return;g=!0;const L=r(u,256,9,0);L.onaudioprocess=({inputBuffer:I})=>{const D=[s(I,y,0),s(I,y,1),s(I,y,2),s(I,y,3),s(I,y,4),s(I,y,5)];D.some((T,S)=>T!==k[S])&&(h.setOrientation(...D),k=D);const F=[s(I,y,6),s(I,y,7),s(I,y,8)];F.some((T,S)=>T!==P[S])&&(h.setPosition(...F),P=F)},b.connect(L)},W=L=>I=>{I!==k[L]&&(k[L]=I,h.setOrientation(...k))},V=L=>I=>{I!==P[L]&&(P[L]=I,h.setPosition(...P))},x=(L,I,D)=>{const F=n(u,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:I});F.connect(b,0,L),F.start(),Object.defineProperty(F.offset,"defaultValue",{get(){return I}});const T=e({context:i},w,F.offset,Ze,Se);return a(T,"value",S=>()=>S.call(T),S=>B=>{try{S.call(T,B)}catch($){if($.code!==9)throw $}_(),w&&D(B)}),T.cancelAndHoldAtTime=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.cancelAndHoldAtTime),T.cancelScheduledValues=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.cancelScheduledValues),T.exponentialRampToValueAtTime=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.exponentialRampToValueAtTime),T.linearRampToValueAtTime=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.linearRampToValueAtTime),T.setTargetAtTime=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.setTargetAtTime),T.setValueAtTime=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.setValueAtTime),T.setValueCurveAtTime=(S=>w?()=>{throw o()}:(...B)=>{const $=S.apply(T,B);return _(),$})(T.setValueCurveAtTime),T};return{forwardX:x(0,0,W(0)),forwardY:x(1,0,W(1)),forwardZ:x(2,-1,W(2)),positionX:x(6,0,V(0)),positionY:x(7,0,V(1)),positionZ:x(8,0,V(2)),upX:x(3,0,W(3)),upY:x(4,1,W(4)),upZ:x(5,0,W(5))}},{forwardX:N,forwardY:p,forwardZ:C,positionX:f,positionY:m,positionZ:d,upX:v,upY:A,upZ:M}=h.forwardX===void 0?l():h;return{get forwardX(){return N},get forwardY(){return p},get forwardZ(){return C},get positionX(){return f},get positionY(){return m},get positionZ(){return d},get upX(){return v},get upY(){return A},get upZ(){return M}}},Ee=e=>"context"in e,ge=e=>Ee(e[0]),ae=(e,t,n,r)=>{for(const o of e)if(n(o)){if(r)return!1;throw Error("The set contains at least one similar element.")}return e.add(t),!0},pt=(e,t,[n,r],o)=>{ae(e,[t,n,r],s=>s[0]===t&&s[1]===n,o)},mt=(e,[t,n,r],o)=>{const s=e.get(t);s===void 0?e.set(t,new Set([[n,r]])):ae(s,[n,r],c=>c[0]===n,o)},It=e=>"inputs"in e,ze=(e,t,n,r)=>{if(It(t)){const o=t.inputs[r];return e.connect(o,n,0),[o,n,0]}return e.connect(t,n,r),[t,n,r]},St=(e,t,n)=>{for(const r of e)if(r[0]===t&&r[1]===n)return e.delete(r),r;return null},$n=(e,t,n)=>Ie(e,r=>r[0]===t&&r[1]===n),Pt=(e,t)=>{if(!we(e).delete(t))throw new Error("Missing the expected event listener.")},Rt=(e,t,n)=>{const r=K(e,t),o=Ie(r,s=>s[0]===n);return r.size===0&&e.delete(t),o},Ye=(e,t,n,r)=>{It(t)?e.disconnect(t.inputs[r],n,0):e.disconnect(t,n,r)},Z=e=>K(gt,e),Ce=e=>K(Nt,e),oe=e=>je.has(e),ve=e=>!de.has(e),Ct=(e,t)=>new Promise(n=>{if(t!==null)n(!0);else{const r=e.createScriptProcessor(256,1,1),o=e.createGain(),s=e.createBuffer(1,2,44100),c=s.getChannelData(0);c[0]=1,c[1]=1;const a=e.createBufferSource();a.buffer=s,a.loop=!0,a.connect(r).connect(e.destination),a.connect(o),a.disconnect(o),r.onaudioprocess=i=>{const u=i.inputBuffer.getChannelData(0);Array.prototype.some.call(u,h=>h===1)?n(!0):n(!1),a.stop(),r.onaudioprocess=null,a.disconnect(r),r.disconnect(e.destination)},a.start()}}),Fe=(e,t)=>{const n=new Map;for(const r of e)for(const o of r){const s=n.get(o);n.set(o,s===void 0?1:s+1)}n.forEach((r,o)=>t(o,r))},_e=e=>"context"in e,Xn=e=>{const t=new Map;e.connect=(n=>(r,o=0,s=0)=>{const c=_e(r)?n(r,o,s):n(r,o),a=t.get(r);return a===void 0?t.set(r,[{input:s,output:o}]):a.every(i=>i.input!==s||i.output!==o)&&a.push({input:s,output:o}),c})(e.connect.bind(e)),e.disconnect=(n=>(r,o,s)=>{if(n.apply(e),r===void 0)t.clear();else if(typeof r=="number")for(const[c,a]of t){const i=a.filter(u=>u.output!==r);i.length===0?t.delete(c):t.set(c,i)}else if(t.has(r))if(o===void 0)t.delete(r);else{const c=t.get(r);if(c!==void 0){const a=c.filter(i=>i.output!==o&&(i.input!==s||s===void 0));a.length===0?t.delete(r):t.set(r,a)}}for(const[c,a]of t)a.forEach(i=>{_e(c)?e.connect(c,i.output,i.input):e.connect(c,i.output)})})(e.disconnect)},zn=(e,t,n,r)=>{const{activeInputs:o,passiveInputs:s}=ye(t),{outputs:c}=z(e),a=we(e),i=u=>{const h=Z(e),l=Ce(t);if(u){const N=Rt(s,e,n);pt(o,e,N,!1),!r&&!oe(e)&&h.connect(l,n)}else{const N=$n(o,e,n);mt(s,N,!1),!r&&!oe(e)&&h.disconnect(l,n)}};return ae(c,[t,n],u=>u[0]===t&&u[1]===n,!0)?(a.add(i),re(e)?pt(o,e,[n,i],!0):mt(s,[e,n,i],!0),!0):!1},Yn=(e,t,n,r)=>{const{activeInputs:o,passiveInputs:s}=z(t),c=St(o[r],e,n);return c===null?[Et(s,e,n,r)[2],!1]:[c[2],!0]},qn=(e,t,n)=>{const{activeInputs:r,passiveInputs:o}=ye(t),s=St(r,e,n);return s===null?[Rt(o,e,n)[1],!1]:[s[2],!0]},He=(e,t,n,r,o)=>{const[s,c]=Yn(e,n,r,o);if(s!==null&&(Pt(e,s),c&&!t&&!oe(e)&&Ye(Z(e),Z(n),r,o)),re(n)){const{activeInputs:a}=z(n);$e(n,a)}},Ke=(e,t,n,r)=>{const[o,s]=qn(e,n,r);o!==null&&(Pt(e,o),s&&!t&&!oe(e)&&Z(e).disconnect(Ce(n),r))},Zn=(e,t)=>{const n=z(e),r=[];for(const o of n.outputs)ge(o)?He(e,t,...o):Ke(e,t,...o),r.push(o[0]);return n.outputs.clear(),r},Hn=(e,t,n)=>{const r=z(e),o=[];for(const s of r.outputs)s[1]===n&&(ge(s)?He(e,t,...s):Ke(e,t,...s),o.push(s[0]),r.outputs.delete(s));return o},Kn=(e,t,n,r,o)=>{const s=z(e);return Array.from(s.outputs).filter(c=>c[0]===n&&(r===void 0||c[1]===r)&&(o===void 0||c[2]===o)).map(c=>(ge(c)?He(e,t,...c):Ke(e,t,...c),s.outputs.delete(c),c[0]))},Qn=(e,t,n,r,o,s,c,a,i,u,h,l,N,p,C,f)=>class extends u{constructor(d,v,A,M){super(A),this._context=d,this._nativeAudioNode=A;const y=h(d);l(y)&&n(Ct,()=>Ct(y,f))!==!0&&Xn(A),gt.set(this,A),vt.set(this,new Set),d.state!=="closed"&&v&&Me(this),e(this,M,A)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(d){this._nativeAudioNode.channelCount=d}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(d){this._nativeAudioNode.channelCountMode=d}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(d){this._nativeAudioNode.channelInterpretation=d}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(d,v=0,A=0){if(v<0||v>=this._nativeAudioNode.numberOfOutputs)throw o();const M=h(this._context),y=C(M);if(N(d)||p(d))throw s();if(Ee(d)){const g=Z(d);try{const P=ze(this._nativeAudioNode,g,v,A),_=ve(this);(y||_)&&this._nativeAudioNode.disconnect(...P),this.context.state!=="closed"&&!_&&ve(d)&&Me(d)}catch(P){throw P.code===12?s():P}if(t(this,d,v,A,y)){const P=i([this],d);Fe(P,r(y))}return d}const b=Ce(d);if(b.name==="playbackRate"&&b.maxValue===1024)throw c();try{this._nativeAudioNode.connect(b,v),(y||ve(this))&&this._nativeAudioNode.disconnect(b,v)}catch(g){throw g.code===12?s():g}if(zn(this,d,v,y)){const g=i([this],d);Fe(g,r(y))}}disconnect(d,v,A){let M;const y=h(this._context),b=C(y);if(d===void 0)M=Zn(this,b);else if(typeof d=="number"){if(d<0||d>=this.numberOfOutputs)throw o();M=Hn(this,b,d)}else{if(v!==void 0&&(v<0||v>=this.numberOfOutputs)||Ee(d)&&A!==void 0&&(A<0||A>=d.numberOfInputs))throw o();if(M=Kn(this,b,d,v,A),M.length===0)throw s()}for(const w of M){const g=i([this],w);Fe(g,a)}}},Jn=(e,t,n,r,o,s,c,a,i,u,h,l,N)=>(p,C,f,m=null,d=null)=>{const v=f.value,A=new un(v),M=C?r(A):null,y={get defaultValue(){return v},get maxValue(){return m===null?f.maxValue:m},get minValue(){return d===null?f.minValue:d},get value(){return f.value},set value(b){f.value=b,y.setValueAtTime(b,p.context.currentTime)},cancelAndHoldAtTime(b){if(typeof f.cancelAndHoldAtTime=="function")M===null&&A.flush(p.context.currentTime),A.add(o(b)),f.cancelAndHoldAtTime(b);else{const w=Array.from(A).pop();M===null&&A.flush(p.context.currentTime),A.add(o(b));const g=Array.from(A).pop();f.cancelScheduledValues(b),w!==g&&g!==void 0&&(g.type==="exponentialRampToValue"?f.exponentialRampToValueAtTime(g.value,g.endTime):g.type==="linearRampToValue"?f.linearRampToValueAtTime(g.value,g.endTime):g.type==="setValue"?f.setValueAtTime(g.value,g.startTime):g.type==="setValueCurve"&&f.setValueCurveAtTime(g.values,g.startTime,g.duration))}return y},cancelScheduledValues(b){return M===null&&A.flush(p.context.currentTime),A.add(s(b)),f.cancelScheduledValues(b),y},exponentialRampToValueAtTime(b,w){if(b===0)throw new RangeError;if(!Number.isFinite(w)||w<0)throw new RangeError;const g=p.context.currentTime;return M===null&&A.flush(g),Array.from(A).length===0&&(A.add(u(v,g)),f.setValueAtTime(v,g)),A.add(c(b,w)),f.exponentialRampToValueAtTime(b,w),y},linearRampToValueAtTime(b,w){const g=p.context.currentTime;return M===null&&A.flush(g),Array.from(A).length===0&&(A.add(u(v,g)),f.setValueAtTime(v,g)),A.add(a(b,w)),f.linearRampToValueAtTime(b,w),y},setTargetAtTime(b,w,g){return M===null&&A.flush(p.context.currentTime),A.add(i(b,w,g)),f.setTargetAtTime(b,w,g),y},setValueAtTime(b,w){return M===null&&A.flush(p.context.currentTime),A.add(u(b,w)),f.setValueAtTime(b,w),y},setValueCurveAtTime(b,w,g){const k=b instanceof Float32Array?b:new Float32Array(b);if(l!==null&&l.name==="webkitAudioContext"){const P=w+g,_=p.context.sampleRate,W=Math.ceil(w*_),V=Math.floor(P*_),x=V-W,L=new Float32Array(x);for(let D=0;D<x;D+=1){const F=(k.length-1)/g*((W+D)/_-w),T=Math.floor(F),S=Math.ceil(F);L[D]=T===S?k[T]:(1-(F-T))*k[T]+(1-(S-F))*k[S]}M===null&&A.flush(p.context.currentTime),A.add(h(L,w,g)),f.setValueCurveAtTime(L,w,g);const I=V/_;I<P&&N(y,L[L.length-1],I),N(y,k[k.length-1],P)}else M===null&&A.flush(p.context.currentTime),A.add(h(k,w,g)),f.setValueCurveAtTime(k,w,g);return y}};return n.set(y,f),t.set(y,p),e(y,M),y},er=e=>({replay(t){for(const n of e)if(n.type==="exponentialRampToValue"){const{endTime:r,value:o}=n;t.exponentialRampToValueAtTime(o,r)}else if(n.type==="linearRampToValue"){const{endTime:r,value:o}=n;t.linearRampToValueAtTime(o,r)}else if(n.type==="setTarget"){const{startTime:r,target:o,timeConstant:s}=n;t.setTargetAtTime(o,r,s)}else if(n.type==="setValue"){const{startTime:r,value:o}=n;t.setValueAtTime(o,r)}else if(n.type==="setValueCurve"){const{duration:r,startTime:o,values:s}=n;t.setValueCurveAtTime(s,o,r)}else throw new Error("Can't apply an unknown automation.")}});class Wt{constructor(t){this._map=new Map(t)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(t,n=null){return this._map.forEach((r,o)=>t.call(n,r,o,this))}get(t){return this._map.get(t)}has(t){return this._map.has(t)}keys(){return this._map.keys()}values(){return this._map.values()}}const tr={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}},nr=(e,t,n,r,o,s,c,a,i,u,h,l,N,p)=>class extends t{constructor(f,m,d){var v;const A=a(f),M=i(A),y=h({...tr,...d});N(y);const b=Ge.get(A),w=b==null?void 0:b.get(m),g=M||A.state!=="closed"?A:(v=c(A))!==null&&v!==void 0?v:A,k=o(g,M?null:f.baseLatency,u,m,w,y),P=M?r(m,y,w):null;super(f,!0,k,P);const _=[];k.parameters.forEach((V,x)=>{const L=n(this,M,V);_.push([x,L])}),this._nativeAudioWorkletNode=k,this._onprocessorerror=null,this._parameters=new Wt(_),M&&e(A,this);const{activeInputs:W}=s(this);l(k,W)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(f){const m=typeof f=="function"?p(this,f):null;this._nativeAudioWorkletNode.onprocessorerror=m;const d=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=d!==null&&d===m?f:d}get parameters(){return this._parameters===null?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}};function Te(e,t,n,r,o){if(typeof e.copyFromChannel=="function")t[n].byteLength===0&&(t[n]=new Float32Array(128)),e.copyFromChannel(t[n],r,o);else{const s=e.getChannelData(r);if(t[n].byteLength===0)t[n]=s.slice(o,o+128);else{const c=new Float32Array(s.buffer,o*Float32Array.BYTES_PER_ELEMENT,128);t[n].set(c)}}}const Dt=(e,t,n,r,o)=>{typeof e.copyToChannel=="function"?t[n].byteLength!==0&&e.copyToChannel(t[n],r,o):t[n].byteLength!==0&&e.getChannelData(r).set(t[n],o)},ke=(e,t)=>{const n=[];for(let r=0;r<e;r+=1){const o=[],s=typeof t=="number"?t:t[r];for(let c=0;c<s;c+=1)o.push(new Float32Array(128));n.push(o)}return n},rr=(e,t)=>{const n=K(Ue,e),r=Z(t);return K(n,r)},or=async(e,t,n,r,o,s,c)=>{const a=t===null?Math.ceil(e.context.length/128)*128:t.length,i=r.channelCount*r.numberOfInputs,u=o.reduce((m,d)=>m+d,0),h=u===0?null:n.createBuffer(u,a,n.sampleRate);if(s===void 0)throw new Error("Missing the processor constructor.");const l=z(e),N=await rr(n,e),p=ke(r.numberOfInputs,r.channelCount),C=ke(r.numberOfOutputs,o),f=Array.from(e.parameters.keys()).reduce((m,d)=>({...m,[d]:new Float32Array(128)}),{});for(let m=0;m<a;m+=128){if(r.numberOfInputs>0&&t!==null)for(let d=0;d<r.numberOfInputs;d+=1)for(let v=0;v<r.channelCount;v+=1)Te(t,p[d],v,v,m);s.parameterDescriptors!==void 0&&t!==null&&s.parameterDescriptors.forEach(({name:d},v)=>{Te(t,f,d,i+v,m)});for(let d=0;d<r.numberOfInputs;d+=1)for(let v=0;v<o[d];v+=1)C[d][v].byteLength===0&&(C[d][v]=new Float32Array(128));try{const d=p.map((A,M)=>l.activeInputs[M].size===0?[]:A),v=c(m/n.sampleRate,n.sampleRate,()=>N.process(d,C,f));if(h!==null)for(let A=0,M=0;A<r.numberOfOutputs;A+=1){for(let y=0;y<o[A];y+=1)Dt(h,C[A],y,M+y,m);M+=o[A]}if(!v)break}catch(d){e.dispatchEvent(new ErrorEvent("processorerror",{colno:d.colno,filename:d.filename,lineno:d.lineno,message:d.message}));break}}return h},sr=(e,t,n,r,o,s,c,a,i,u,h,l,N,p,C,f)=>(m,d,v)=>{const A=new WeakMap;let M=null;const y=async(b,w)=>{let g=h(b),k=null;const P=Tt(g,w),_=Array.isArray(d.outputChannelCount)?d.outputChannelCount:Array.from(d.outputChannelCount);if(l===null){const W=_.reduce((I,D)=>I+D,0),V=o(w,{channelCount:Math.max(1,W),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,W)}),x=[];for(let I=0;I<b.numberOfOutputs;I+=1)x.push(r(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:_[I]}));const L=c(w,{channelCount:d.channelCount,channelCountMode:d.channelCountMode,channelInterpretation:d.channelInterpretation,gain:1});L.connect=t.bind(null,x),L.disconnect=i.bind(null,x),k=[V,x,L]}else P||(g=new l(w,m));if(A.set(w,k===null?g:k[2]),k!==null){if(M===null){if(v===void 0)throw new Error("Missing the processor constructor.");if(N===null)throw new Error("Missing the native OfflineAudioContext constructor.");const D=b.channelCount*b.numberOfInputs,F=v.parameterDescriptors===void 0?0:v.parameterDescriptors.length,T=D+F;M=or(b,T===0?null:await(async()=>{const B=new N(T,Math.ceil(b.context.length/128)*128,w.sampleRate),$=[],ue=[];for(let G=0;G<d.numberOfInputs;G+=1)$.push(c(B,{channelCount:d.channelCount,channelCountMode:d.channelCountMode,channelInterpretation:d.channelInterpretation,gain:1})),ue.push(o(B,{channelCount:d.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:d.channelCount}));const le=await Promise.all(Array.from(b.parameters.values()).map(async G=>{const Y=s(B,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:G.value});return await p(B,G,Y.offset),Y})),fe=r(B,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,D+F)});for(let G=0;G<d.numberOfInputs;G+=1){$[G].connect(ue[G]);for(let Y=0;Y<d.channelCount;Y+=1)ue[G].connect(fe,Y,G*d.channelCount+Y)}for(const[G,Y]of le.entries())Y.connect(fe,0,D+G),Y.start(0);return fe.connect(B.destination),await Promise.all($.map(G=>C(b,B,G))),f(B)})(),w,d,_,v,u)}const W=await M,V=n(w,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[x,L,I]=k;W!==null&&(V.buffer=W,V.start(0)),V.connect(x);for(let D=0,F=0;D<b.numberOfOutputs;D+=1){const T=L[D];for(let S=0;S<_[D];S+=1)x.connect(T,F+S,S);F+=_[D]}return I}if(P)for(const[W,V]of b.parameters.entries())await e(w,V,g.parameters.get(W));else for(const[W,V]of b.parameters.entries())await p(w,V,g.parameters.get(W));return await C(b,w,g),g};return{render(b,w){a(w,b);const g=A.get(w);return g!==void 0?Promise.resolve(g):y(b,w)}}},cr=(e,t)=>(n,r)=>{const o=t.get(n);if(o!==void 0)return o;const s=e.get(n);if(s!==void 0)return s;try{const c=r();return c instanceof Promise?(e.set(n,c),c.catch(()=>!1).then(a=>(e.delete(n),t.set(n,a),a))):(t.set(n,c),c)}catch{return t.set(n,!1),!1}},ar=e=>(t,n,r)=>e(n,t,r),ir=e=>(t,n,r=0,o=0)=>{const s=t[r];if(s===void 0)throw e();return _e(n)?s.connect(n,0,o):s.connect(n,0)},ur=e=>t=>(e[0]=t,e[0]),lr=(e,t,n,r,o,s,c,a)=>(i,u)=>{const h=t.get(i);if(h===void 0)throw new Error("Missing the expected cycle count.");const l=s(i.context),N=a(l);if(h===u){if(t.delete(i),!N&&c(i)){const p=r(i),{outputs:C}=n(i);for(const f of C)if(ge(f)){const m=r(f[0]);e(p,m,f[1],f[2])}else{const m=o(f[0]);p.connect(m,f[1])}}}else t.set(i,h-u)},fr=e=>(t,n,r,o)=>e(t[o],s=>s[0]===n&&s[1]===r),dr=e=>(t,n)=>{e(t).delete(n)},hr=e=>"delayTime"in e,pr=(e,t,n)=>function r(o,s){const c=Ee(s)?s:n(e,s);if(hr(c))return[];if(o[0]===c)return[o];if(o.includes(c))return[];const{outputs:a}=t(c);return Array.from(a).map(i=>r([...o,c],i[0])).reduce((i,u)=>i.concat(u),[])},Oe=(e,t,n)=>{const r=t[n];if(r===void 0)throw e();return r},mr=e=>(t,n=void 0,r=void 0,o=0)=>n===void 0?t.forEach(s=>s.disconnect()):typeof n=="number"?Oe(e,t,n).disconnect():_e(n)?r===void 0?t.forEach(s=>s.disconnect(n)):o===void 0?Oe(e,t,r).disconnect(n,0):Oe(e,t,r).disconnect(n,0,o):r===void 0?t.forEach(s=>s.disconnect(n)):Oe(e,t,r).disconnect(n,0),Cr=e=>t=>new Promise((n,r)=>{if(e===null){r(new SyntaxError);return}const o=e.document.head;if(o===null)r(new SyntaxError);else{const s=e.document.createElement("script"),c=new Blob([t],{type:"application/javascript"}),a=URL.createObjectURL(c),i=e.onerror,u=()=>{e.onerror=i,URL.revokeObjectURL(a)};e.onerror=(h,l,N,p,C)=>{if(l===a||l===e.location.href&&N===1&&p===1)return u(),r(C),!1;if(i!==null)return i(h,l,N,p,C)},s.onerror=()=>{u(),r(new SyntaxError)},s.onload=()=>{u(),n()},s.src=a,s.type="module",o.appendChild(s)}}),Ar=e=>class{constructor(n){this._nativeEventTarget=n,this._listeners=new WeakMap}addEventListener(n,r,o){if(r!==null){let s=this._listeners.get(r);s===void 0&&(s=e(this,r),typeof r=="function"&&this._listeners.set(r,s)),this._nativeEventTarget.addEventListener(n,s,o)}}dispatchEvent(n){return this._nativeEventTarget.dispatchEvent(n)}removeEventListener(n,r,o){const s=r===null?void 0:this._listeners.get(r);this._nativeEventTarget.removeEventListener(n,s===void 0?null:s,o)}},wr=e=>(t,n,r)=>{Object.defineProperties(e,{currentFrame:{configurable:!0,get(){return Math.round(t*n)}},currentTime:{configurable:!0,get(){return t}}});try{return r()}finally{e!==null&&(delete e.currentFrame,delete e.currentTime)}},yr=e=>async t=>{try{const n=await fetch(t);if(n.ok)return[await n.text(),n.url]}catch{}throw e()},gr=(e,t)=>n=>t(e,n),br=e=>t=>{const n=e(t);if(n.renderer===null)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return n.renderer},Nr=e=>t=>{var n;return(n=e.get(t))!==null&&n!==void 0?n:0},Or=e=>t=>{const n=e(t);if(n.renderer===null)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return n.renderer},vr=e=>t=>e.get(t),H=()=>new DOMException("","InvalidStateError"),Mr=e=>t=>{const n=e.get(t);if(n===void 0)throw H();return n},Er=(e,t)=>n=>{let r=e.get(n);if(r!==void 0)return r;if(t===null)throw new Error("Missing the native OfflineAudioContext constructor.");return r=new t(1,1,44100),e.set(n,r),r},_r=e=>t=>{const n=e.get(t);if(n===void 0)throw new Error("The context has no set of AudioWorkletNodes.");return n},Tr=()=>new DOMException("","InvalidAccessError"),kr=(e,t,n,r,o,s)=>c=>(a,i)=>{const u=e.get(a);if(u===void 0){if(!c&&s(a)){const h=r(a),{outputs:l}=n(a);for(const N of l)if(ge(N)){const p=r(N[0]);t(h,p,N[1],N[2])}else{const p=o(N[0]);h.disconnect(p,N[1])}}e.set(a,i)}else e.set(a,u+i)},Ir=e=>t=>e!==null&&t instanceof e,Sr=e=>t=>e!==null&&typeof e.AudioNode=="function"&&t instanceof e.AudioNode,Pr=e=>t=>e!==null&&typeof e.AudioParam=="function"&&t instanceof e.AudioParam,Rr=e=>t=>e!==null&&t instanceof e,Wr=e=>e!==null&&e.isSecureContext,Dr=(e,t,n,r)=>class extends e{constructor(s,c){const a=n(s),i=t(a,c);if(r(a))throw new TypeError;super(s,!0,i,null),this._nativeMediaStreamAudioSourceNode=i}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}},Lr=(e,t,n,r,o)=>class extends r{constructor(c={}){if(o===null)throw new Error("Missing the native AudioContext constructor.");let a;try{a=new o(c)}catch(h){throw h.code===12&&h.message==="sampleRate is not in range"?t():h}if(a===null)throw n();if(!Fn(c.latencyHint))throw new TypeError(`The provided value '${c.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(c.sampleRate!==void 0&&a.sampleRate!==c.sampleRate)throw t();super(a,2);const{latencyHint:i}=c,{sampleRate:u}=a;if(this._baseLatency=typeof a.baseLatency=="number"?a.baseLatency:i==="balanced"?512/u:i==="interactive"||i===void 0?256/u:i==="playback"?1024/u:Math.max(2,Math.min(128,Math.round(i*u/128)))*128/u,this._nativeAudioContext=a,o.name==="webkitAudioContext"?(this._nativeGainNode=a.createGain(),this._nativeOscillatorNode=a.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(a.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,a.state==="running"){this._state="suspended";const h=()=>{this._state==="suspended"&&(this._state=null),a.removeEventListener("statechange",h)};a.addEventListener("statechange",h)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){return this.state==="closed"?this._nativeAudioContext.close().then(()=>{throw e()}):(this._state==="suspended"&&(this._state=null),this._nativeAudioContext.close().then(()=>{this._nativeGainNode!==null&&this._nativeOscillatorNode!==null&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),xn(this)}))}resume(){return this._state==="suspended"?new Promise((c,a)=>{const i=()=>{this._nativeAudioContext.removeEventListener("statechange",i),this._nativeAudioContext.state==="running"?c():this.resume().then(c,a)};this._nativeAudioContext.addEventListener("statechange",i)}):this._nativeAudioContext.resume().catch(c=>{throw c===void 0||c.code===15?e():c})}suspend(){return this._nativeAudioContext.suspend().catch(c=>{throw c===void 0?e():c})}},Br=(e,t,n,r,o,s)=>class extends n{constructor(a,i){super(a),this._nativeContext=a,Ot.set(this,a),r(a)&&o.set(a,new Set),this._destination=new e(this,i),this._listener=t(this,a),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(a){const i=typeof a=="function"?s(this,a):null;this._nativeContext.onstatechange=i;const u=this._nativeContext.onstatechange;this._onstatechange=u!==null&&u===i?a:u}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}},At=e=>{const t=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const n=e.decodeAudioData(t.buffer,()=>{});return n===void 0?!1:(n.catch(()=>{}),!0)}catch{}return!1},Vr=(e,t)=>(n,r,o)=>{const s=new Set;return n.connect=(c=>(a,i=0,u=0)=>{const h=s.size===0;if(t(a))return c.call(n,a,i,u),e(s,[a,i,u],l=>l[0]===a&&l[1]===i&&l[2]===u,!0),h&&r(),a;c.call(n,a,i),e(s,[a,i],l=>l[0]===a&&l[1]===i,!0),h&&r()})(n.connect),n.disconnect=(c=>(a,i,u)=>{const h=s.size>0;if(a===void 0)c.apply(n),s.clear();else if(typeof a=="number"){c.call(n,a);for(const N of s)N[1]===a&&s.delete(N)}else{t(a)?c.call(n,a,i,u):c.call(n,a,i);for(const N of s)N[0]===a&&(i===void 0||N[1]===i)&&(u===void 0||N[2]===u)&&s.delete(N)}const l=s.size===0;h&&l&&o()})(n.disconnect),n},ne=(e,t,n)=>{const r=t[n];r!==void 0&&r!==e[n]&&(e[n]=r)},be=(e,t)=>{ne(e,t,"channelCount"),ne(e,t,"channelCountMode"),ne(e,t,"channelInterpretation")},xr=e=>e===null?null:e.hasOwnProperty("AudioBuffer")?e.AudioBuffer:null,Qe=(e,t,n)=>{const r=t[n];r!==void 0&&r!==e[n].value&&(e[n].value=r)},Fr=e=>{e.start=(t=>{let n=!1;return(r=0,o=0,s)=>{if(n)throw H();t.call(e,r,o,s),n=!0}})(e.start)},Lt=e=>{e.start=(t=>(n=0,r=0,o)=>{if(typeof o=="number"&&o<0||r<0||n<0)throw new RangeError("The parameters can't be negative.");t.call(e,n,r,o)})(e.start)},Bt=e=>{e.stop=(t=>(n=0)=>{if(n<0)throw new RangeError("The parameter can't be negative.");t.call(e,n)})(e.stop)},jr=(e,t,n,r,o,s,c,a,i,u,h)=>(l,N)=>{const p=l.createBufferSource();return be(p,N),Qe(p,N,"playbackRate"),ne(p,N,"buffer"),ne(p,N,"loop"),ne(p,N,"loopEnd"),ne(p,N,"loopStart"),t(n,()=>n(l))||Fr(p),t(r,()=>r(l))||i(p),t(o,()=>o(l))||u(p,l),t(s,()=>s(l))||Lt(p),t(c,()=>c(l))||h(p,l),t(a,()=>a(l))||Bt(p),e(l,p),p},Gr=e=>e===null?null:e.hasOwnProperty("AudioContext")?e.AudioContext:e.hasOwnProperty("webkitAudioContext")?e.webkitAudioContext:null,Ur=(e,t)=>(n,r,o)=>{const s=n.destination;if(s.channelCount!==r)try{s.channelCount=r}catch{}o&&s.channelCountMode!=="explicit"&&(s.channelCountMode="explicit"),s.maxChannelCount===0&&Object.defineProperty(s,"maxChannelCount",{value:r});const c=e(n,{channelCount:r,channelCountMode:s.channelCountMode,channelInterpretation:s.channelInterpretation,gain:1});return t(c,"channelCount",a=>()=>a.call(c),a=>i=>{a.call(c,i);try{s.channelCount=i}catch(u){if(i>s.maxChannelCount)throw u}}),t(c,"channelCountMode",a=>()=>a.call(c),a=>i=>{a.call(c,i),s.channelCountMode=i}),t(c,"channelInterpretation",a=>()=>a.call(c),a=>i=>{a.call(c,i),s.channelInterpretation=i}),Object.defineProperty(c,"maxChannelCount",{get:()=>s.maxChannelCount}),c.connect(s),c},$r=e=>e===null?null:e.hasOwnProperty("AudioWorkletNode")?e.AudioWorkletNode:null,Xr=e=>{const{port1:t}=new MessageChannel;try{t.postMessage(e)}finally{t.close()}},zr=(e,t,n,r,o)=>(s,c,a,i,u,h)=>{if(a!==null)try{const l=new a(s,i,h),N=new Map;let p=null;if(Object.defineProperties(l,{channelCount:{get:()=>h.channelCount,set:()=>{throw e()}},channelCountMode:{get:()=>"explicit",set:()=>{throw e()}},onprocessorerror:{get:()=>p,set:C=>{typeof p=="function"&&l.removeEventListener("processorerror",p),p=typeof C=="function"?C:null,typeof p=="function"&&l.addEventListener("processorerror",p)}}}),l.addEventListener=(C=>(...f)=>{if(f[0]==="processorerror"){const m=typeof f[1]=="function"?f[1]:typeof f[1]=="object"&&f[1]!==null&&typeof f[1].handleEvent=="function"?f[1].handleEvent:null;if(m!==null){const d=N.get(f[1]);d!==void 0?f[1]=d:(f[1]=v=>{v.type==="error"?(Object.defineProperties(v,{type:{value:"processorerror"}}),m(v)):m(new ErrorEvent(f[0],{...v}))},N.set(m,f[1]))}}return C.call(l,"error",f[1],f[2]),C.call(l,...f)})(l.addEventListener),l.removeEventListener=(C=>(...f)=>{if(f[0]==="processorerror"){const m=N.get(f[1]);m!==void 0&&(N.delete(f[1]),f[1]=m)}return C.call(l,"error",f[1],f[2]),C.call(l,f[0],f[1],f[2])})(l.removeEventListener),h.numberOfOutputs!==0){const C=n(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return l.connect(C).connect(s.destination),o(l,()=>C.disconnect(),()=>C.connect(s.destination))}return l}catch(l){throw l.code===11?r():l}if(u===void 0)throw r();return Xr(h),t(s,c,u,h)},Yr=(e,t)=>e===null?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(e*t))))),qr=e=>new Promise((t,n)=>{const{port1:r,port2:o}=new MessageChannel;r.onmessage=({data:s})=>{r.close(),o.close(),t(s)},r.onmessageerror=({data:s})=>{r.close(),o.close(),n(s)},o.postMessage(e)}),Zr=async(e,t)=>{const n=await qr(t);return new e(n)},Hr=(e,t,n,r)=>{let o=Ue.get(e);o===void 0&&(o=new WeakMap,Ue.set(e,o));const s=Zr(n,r);return o.set(t,s),s},Kr=(e,t,n,r,o,s,c,a,i,u,h,l,N)=>(p,C,f,m)=>{if(m.numberOfInputs===0&&m.numberOfOutputs===0)throw i();const d=Array.isArray(m.outputChannelCount)?m.outputChannelCount:Array.from(m.outputChannelCount);if(d.some(O=>O<1))throw i();if(d.length!==m.numberOfOutputs)throw t();if(m.channelCountMode!=="explicit")throw i();const v=m.channelCount*m.numberOfInputs,A=d.reduce((O,E)=>O+E,0),M=f.parameterDescriptors===void 0?0:f.parameterDescriptors.length;if(v+M>6||A>6)throw i();const y=new MessageChannel,b=[],w=[];for(let O=0;O<m.numberOfInputs;O+=1)b.push(c(p,{channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation,gain:1})),w.push(o(p,{channelCount:m.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:m.channelCount}));const g=[];if(f.parameterDescriptors!==void 0)for(const{defaultValue:O,maxValue:E,minValue:X,name:j}of f.parameterDescriptors){const R=s(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:m.parameterData[j]!==void 0?m.parameterData[j]:O===void 0?0:O});Object.defineProperties(R.offset,{defaultValue:{get:()=>O===void 0?0:O},maxValue:{get:()=>E===void 0?Ze:E},minValue:{get:()=>X===void 0?Se:X}}),g.push(R)}const k=r(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,v+M)}),P=Yr(C,p.sampleRate),_=a(p,P,v+M,Math.max(1,A)),W=o(p,{channelCount:Math.max(1,A),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,A)}),V=[];for(let O=0;O<m.numberOfOutputs;O+=1)V.push(r(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:d[O]}));for(let O=0;O<m.numberOfInputs;O+=1){b[O].connect(w[O]);for(let E=0;E<m.channelCount;E+=1)w[O].connect(k,E,O*m.channelCount+E)}const x=new Wt(f.parameterDescriptors===void 0?[]:f.parameterDescriptors.map(({name:O},E)=>{const X=g[E];return X.connect(k,0,v+E),X.start(0),[O,X.offset]}));k.connect(_);let L=m.channelInterpretation,I=null;const D=m.numberOfOutputs===0?[_]:V,F={get bufferSize(){return P},get channelCount(){return m.channelCount},set channelCount(O){throw n()},get channelCountMode(){return m.channelCountMode},set channelCountMode(O){throw n()},get channelInterpretation(){return L},set channelInterpretation(O){for(const E of b)E.channelInterpretation=O;L=O},get context(){return _.context},get inputs(){return b},get numberOfInputs(){return m.numberOfInputs},get numberOfOutputs(){return m.numberOfOutputs},get onprocessorerror(){return I},set onprocessorerror(O){typeof I=="function"&&F.removeEventListener("processorerror",I),I=typeof O=="function"?O:null,typeof I=="function"&&F.addEventListener("processorerror",I)},get parameters(){return x},get port(){return y.port2},addEventListener(...O){return _.addEventListener(O[0],O[1],O[2])},connect:e.bind(null,D),disconnect:u.bind(null,D),dispatchEvent(...O){return _.dispatchEvent(O[0])},removeEventListener(...O){return _.removeEventListener(O[0],O[1],O[2])}},T=new Map;y.port1.addEventListener=(O=>(...E)=>{if(E[0]==="message"){const X=typeof E[1]=="function"?E[1]:typeof E[1]=="object"&&E[1]!==null&&typeof E[1].handleEvent=="function"?E[1].handleEvent:null;if(X!==null){const j=T.get(E[1]);j!==void 0?E[1]=j:(E[1]=R=>{h(p.currentTime,p.sampleRate,()=>X(R))},T.set(X,E[1]))}}return O.call(y.port1,E[0],E[1],E[2])})(y.port1.addEventListener),y.port1.removeEventListener=(O=>(...E)=>{if(E[0]==="message"){const X=T.get(E[1]);X!==void 0&&(T.delete(E[1]),E[1]=X)}return O.call(y.port1,E[0],E[1],E[2])})(y.port1.removeEventListener);let S=null;Object.defineProperty(y.port1,"onmessage",{get:()=>S,set:O=>{typeof S=="function"&&y.port1.removeEventListener("message",S),S=typeof O=="function"?O:null,typeof S=="function"&&(y.port1.addEventListener("message",S),y.port1.start())}}),f.prototype.port=y.port1;let B=null;Hr(p,F,f,m).then(O=>B=O);const ue=ke(m.numberOfInputs,m.channelCount),le=ke(m.numberOfOutputs,d),fe=f.parameterDescriptors===void 0?[]:f.parameterDescriptors.reduce((O,{name:E})=>({...O,[E]:new Float32Array(128)}),{});let G=!0;const Y=()=>{m.numberOfOutputs>0&&_.disconnect(W);for(let O=0,E=0;O<m.numberOfOutputs;O+=1){const X=V[O];for(let j=0;j<d[O];j+=1)W.disconnect(X,E+j,j);E+=d[O]}},Ne=new Map;_.onaudioprocess=({inputBuffer:O,outputBuffer:E})=>{if(B!==null){const X=l(F);for(let j=0;j<P;j+=128){for(let R=0;R<m.numberOfInputs;R+=1)for(let U=0;U<m.channelCount;U+=1)Te(O,ue[R],U,U,j);f.parameterDescriptors!==void 0&&f.parameterDescriptors.forEach(({name:R},U)=>{Te(O,fe,R,v+U,j)});for(let R=0;R<m.numberOfInputs;R+=1)for(let U=0;U<d[R];U+=1)le[R][U].byteLength===0&&(le[R][U]=new Float32Array(128));try{const R=ue.map((q,ee)=>{if(X[ee].size>0)return Ne.set(ee,P/128),q;const xe=Ne.get(ee);return xe===void 0?[]:(q.every(cn=>cn.every(an=>an===0))&&(xe===1?Ne.delete(ee):Ne.set(ee,xe-1)),q)});G=h(p.currentTime+j/p.sampleRate,p.sampleRate,()=>B.process(R,le,fe));for(let q=0,ee=0;q<m.numberOfOutputs;q+=1){for(let me=0;me<d[q];me+=1)Dt(E,le[q],me,ee+me,j);ee+=d[q]}}catch(R){G=!1,F.dispatchEvent(new ErrorEvent("processorerror",{colno:R.colno,filename:R.filename,lineno:R.lineno,message:R.message}))}if(!G){for(let R=0;R<m.numberOfInputs;R+=1){b[R].disconnect(w[R]);for(let U=0;U<m.channelCount;U+=1)w[j].disconnect(k,U,R*m.channelCount+U)}if(f.parameterDescriptors!==void 0){const R=f.parameterDescriptors.length;for(let U=0;U<R;U+=1){const q=g[U];q.disconnect(k,0,v+U),q.stop()}}k.disconnect(_),_.onaudioprocess=null,Be?Y():it();break}}}};let Be=!1;const Ve=c(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),at=()=>_.connect(Ve).connect(p.destination),it=()=>{_.disconnect(Ve),Ve.disconnect()},on=()=>{if(G){it(),m.numberOfOutputs>0&&_.connect(W);for(let O=0,E=0;O<m.numberOfOutputs;O+=1){const X=V[O];for(let j=0;j<d[O];j+=1)W.connect(X,E+j,j);E+=d[O]}}Be=!0},sn=()=>{G&&(at(),Y()),Be=!1};return at(),N(F,on,sn)},Qr=(e,t)=>(n,r)=>{const o=n.createChannelMerger(r.numberOfInputs);return e!==null&&e.name==="webkitAudioContext"&&t(n,o),be(o,r),o},Jr=e=>{const t=e.numberOfOutputs;Object.defineProperty(e,"channelCount",{get:()=>t,set:n=>{if(n!==t)throw H()}}),Object.defineProperty(e,"channelCountMode",{get:()=>"explicit",set:n=>{if(n!=="explicit")throw H()}}),Object.defineProperty(e,"channelInterpretation",{get:()=>"discrete",set:n=>{if(n!=="discrete")throw H()}})},Vt=(e,t)=>{const n=e.createChannelSplitter(t.numberOfOutputs);return be(n,t),Jr(n),n},eo=(e,t,n,r,o)=>(s,c)=>{if(s.createConstantSource===void 0)return n(s,c);const a=s.createConstantSource();return be(a,c),Qe(a,c,"offset"),t(r,()=>r(s))||Lt(a),t(o,()=>o(s))||Bt(a),e(s,a),a},xt=(e,t)=>(e.connect=t.connect.bind(t),e.disconnect=t.disconnect.bind(t),e),to=(e,t,n,r)=>(o,{offset:s,...c})=>{const a=o.createBuffer(1,2,44100),i=t(o,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),u=n(o,{...c,gain:s}),h=a.getChannelData(0);h[0]=1,h[1]=1,i.buffer=a,i.loop=!0;const l={get bufferSize(){},get channelCount(){return u.channelCount},set channelCount(C){u.channelCount=C},get channelCountMode(){return u.channelCountMode},set channelCountMode(C){u.channelCountMode=C},get channelInterpretation(){return u.channelInterpretation},set channelInterpretation(C){u.channelInterpretation=C},get context(){return u.context},get inputs(){return[]},get numberOfInputs(){return i.numberOfInputs},get numberOfOutputs(){return u.numberOfOutputs},get offset(){return u.gain},get onended(){return i.onended},set onended(C){i.onended=C},addEventListener(...C){return i.addEventListener(C[0],C[1],C[2])},dispatchEvent(...C){return i.dispatchEvent(C[0])},removeEventListener(...C){return i.removeEventListener(C[0],C[1],C[2])},start(C=0){i.start.call(i,C)},stop(C=0){i.stop.call(i,C)}},N=()=>i.connect(u),p=()=>i.disconnect(u);return e(o,i),r(xt(l,u),N,p)},te=(e,t)=>{const n=e.createGain();return be(n,t),Qe(n,t,"gain"),n},no=(e,{mediaStream:t})=>{const n=t.getAudioTracks();n.sort((s,c)=>s.id<c.id?-1:s.id>c.id?1:0);const r=n.slice(0,1),o=e.createMediaStreamSource(new MediaStream(r));return Object.defineProperty(o,"mediaStream",{value:t}),o},ro=e=>e===null?null:e.hasOwnProperty("OfflineAudioContext")?e.OfflineAudioContext:e.hasOwnProperty("webkitOfflineAudioContext")?e.webkitOfflineAudioContext:null,Je=(e,t,n,r)=>e.createScriptProcessor(t,n,r),ie=()=>new DOMException("","NotSupportedError"),oo=(e,t)=>(n,r,o)=>(e(r).replay(o),t(r,n,o)),so=(e,t,n)=>async(r,o,s)=>{const c=e(r);await Promise.all(c.activeInputs.map((a,i)=>Array.from(a).map(async([u,h])=>{const N=await t(u).render(u,o),p=r.context.destination;!n(u)&&(r!==p||!n(r))&&N.connect(s,h,i)})).reduce((a,i)=>[...a,...i],[]))},co=(e,t,n)=>async(r,o,s)=>{const c=t(r);await Promise.all(Array.from(c.activeInputs).map(async([a,i])=>{const h=await e(a).render(a,o);n(a)||h.connect(s,i)}))},ao=(e,t,n,r)=>o=>e(At,()=>At(o))?Promise.resolve(e(r,r)).then(s=>{if(!s){const c=n(o,512,0,1);o.oncomplete=()=>{c.onaudioprocess=null,c.disconnect()},c.onaudioprocess=()=>o.currentTime,c.connect(o.destination)}return o.startRendering()}):new Promise(s=>{const c=t(o,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});o.oncomplete=a=>{c.disconnect(),s(a.renderedBuffer)},c.connect(o.destination),o.startRendering()}),io=e=>(t,n)=>{e.set(t,n)},uo=e=>()=>{if(e===null)return!1;try{new e({length:1,sampleRate:44100})}catch{return!1}return!0},lo=(e,t)=>async()=>{if(e===null)return!0;if(t===null)return!1;const n=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),r=new t(1,128,44100),o=URL.createObjectURL(n);let s=!1,c=!1;try{await r.audioWorklet.addModule(o);const a=new e(r,"a",{numberOfOutputs:0}),i=r.createOscillator();a.port.onmessage=()=>s=!0,a.onprocessorerror=()=>c=!0,i.connect(a),i.start(0),await r.startRendering(),await new Promise(u=>setTimeout(u))}catch{}finally{URL.revokeObjectURL(o)}return s&&!c},fo=(e,t)=>()=>{if(t===null)return Promise.resolve(!1);const n=new t(1,1,44100),r=e(n,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(o=>{n.oncomplete=()=>{r.disconnect(),o(n.currentTime!==0)},n.startRendering()})},ho=()=>new DOMException("","UnknownError"),po=()=>typeof window>"u"?null:window,mo=(e,t)=>n=>{n.copyFromChannel=(r,o,s=0)=>{const c=e(s),a=e(o);if(a>=n.numberOfChannels)throw t();const i=n.length,u=n.getChannelData(a),h=r.length;for(let l=c<0?-c:0;l+c<i&&l<h;l+=1)r[l]=u[l+c]},n.copyToChannel=(r,o,s=0)=>{const c=e(s),a=e(o);if(a>=n.numberOfChannels)throw t();const i=n.length,u=n.getChannelData(a),h=r.length;for(let l=c<0?-c:0;l+c<i&&l<h;l+=1)u[l+c]=r[l]}},Co=e=>t=>{t.copyFromChannel=(n=>(r,o,s=0)=>{const c=e(s),a=e(o);if(c<t.length)return n.call(t,r,a,c)})(t.copyFromChannel),t.copyToChannel=(n=>(r,o,s=0)=>{const c=e(s),a=e(o);if(c<t.length)return n.call(t,r,a,c)})(t.copyToChannel)},Ao=e=>(t,n)=>{const r=n.createBuffer(1,1,44100);t.buffer===null&&(t.buffer=r),e(t,"buffer",o=>()=>{const s=o.call(t);return s===r?null:s},o=>s=>o.call(t,s===null?r:s))},wo=(e,t)=>(n,r)=>{r.channelCount=1,r.channelCountMode="explicit",Object.defineProperty(r,"channelCount",{get:()=>1,set:()=>{throw e()}}),Object.defineProperty(r,"channelCountMode",{get:()=>"explicit",set:()=>{throw e()}});const o=n.createBufferSource();t(r,()=>{const a=r.numberOfInputs;for(let i=0;i<a;i+=1)o.connect(r,0,i)},()=>o.disconnect(r))},yo=(e,t,n)=>e.copyFromChannel===void 0?e.getChannelData(n)[0]:(e.copyFromChannel(t,n),t[0]),et=(e,t,n,r)=>{let o=e;for(;!o.hasOwnProperty(t);)o=Object.getPrototypeOf(o);const{get:s,set:c}=Object.getOwnPropertyDescriptor(o,t);Object.defineProperty(e,t,{get:n(s),set:r(c)})},go=e=>({...e,outputChannelCount:e.outputChannelCount!==void 0?e.outputChannelCount:e.numberOfInputs===1&&e.numberOfOutputs===1?[e.channelCount]:Array.from({length:e.numberOfOutputs},()=>1)}),Ft=(e,t,n)=>{try{e.setValueAtTime(t,n)}catch(r){if(r.code!==9)throw r;Ft(e,t,n+1e-7)}},bo=e=>{const t=e.createBufferSource();t.start();try{t.start()}catch{return!0}return!1},No=e=>{const t=e.createBufferSource(),n=e.createBuffer(1,1,44100);t.buffer=n;try{t.start(0,1)}catch{return!1}return!0},Oo=e=>{const t=e.createBufferSource();t.start();try{t.stop()}catch{return!1}return!0},jt=e=>{const t=e.createOscillator();try{t.start(-1)}catch(n){return n instanceof RangeError}return!1},vo=e=>{const t=e.createBuffer(1,1,44100),n=e.createBufferSource();n.buffer=t,n.start(),n.stop();try{return n.stop(),!0}catch{return!1}},Gt=e=>{const t=e.createOscillator();try{t.stop(-1)}catch(n){return n instanceof RangeError}return!1},Mo=e=>{const{port1:t,port2:n}=new MessageChannel;try{t.postMessage(e)}finally{t.close(),n.close()}},Eo=e=>{e.start=(t=>(n=0,r=0,o)=>{const s=e.buffer,c=s===null?r:Math.min(s.duration,r);s!==null&&c>s.duration-.5/e.context.sampleRate?t.call(e,n,0,0):t.call(e,n,c,o)})(e.start)},_o=(e,t)=>{const n=t.createGain();e.connect(n);const r=(o=>()=>{o.call(e,n),e.removeEventListener("ended",r)})(e.disconnect);e.addEventListener("ended",r),xt(e,n),e.stop=(o=>{let s=!1;return(c=0)=>{if(s)try{o.call(e,c)}catch{n.gain.setValueAtTime(0,c)}else o.call(e,c),s=!0}})(e.stop)},Pe=(e,t)=>n=>{const r={value:e};return Object.defineProperties(n,{currentTarget:r,target:r}),typeof t=="function"?t.call(e,n):t.handleEvent.call(e,n)},To=wn(ae),ko=vn(ae),Io=fr(Ie),So=new WeakMap,Po=Nr(So),he=cr(new Map,new WeakMap),Q=po(),Ut=br(z),tt=so(z,Ut,oe),se=Mr(Ot),pe=ro(Q),J=Rr(pe),$t=new WeakMap,Xt=Ar(Pe),Re=Gr(Q),Ro=Ir(Re),zt=Sr(Q),Wo=Pr(Q),Ae=$r(Q),We=Qn(yn(yt),On(To,ko,ze,Io,Ye,z,Po,we,Z,ae,re,oe,ve),he,kr(je,Ye,z,Z,Ce,re),ce,Tr,ie,lr(ze,je,z,Z,Ce,se,re,J),pr($t,z,K),Xt,se,Ro,zt,Wo,J,Ae),Do=new WeakSet,wt=xr(Q),Yt=ur(new Uint32Array(1)),Lo=mo(Yt,ce),Bo=Co(Yt),ls=kn(Do,he,ie,wt,pe,uo(wt),Lo,Bo),nt=Mn(te),qt=co(Ut,ye,oe),Zt=ar(qt),De=jr(nt,he,bo,No,Oo,jt,vo,Gt,Eo,Ao(et),_o),Ht=oo(Or(ye),qt),Vo=Pn(Zt,De,Z,Ht,tt),rt=Jn(gn(bt),$t,Nt,er,Cn,mn,pn,hn,dn,fn,ln,Re,Ft),fs=Sn(We,Vo,rt,H,De,se,J,Pe),xo=jn(We,Gn,ce,H,Ur(te,et),se,J,tt),Le=Vr(ae,zt),Fo=wo(H,Le),ot=Qr(Re,Fo),jo=to(nt,De,te,Le),st=eo(nt,he,jo,jt,Gt),Go=ao(he,te,Je,fo(te,pe)),Uo=Un(rt,ot,st,Je,ie,yo,J,et),Kt=new WeakMap,$o=Br(xo,Uo,Xt,J,Kt,Pe),Qt=Wr(Q),ct=wr(Q),Jt=new WeakMap,Xo=Er(Jt,pe),ds=Qt?Nn(he,ie,Cr(Q),ct,yr(An),se,Xo,J,Ae,new WeakMap,new WeakMap,lo(Ae,pe),Q):void 0,hs=Dr(We,no,se,J),en=_r(Kt),zo=En(en),tn=ir(ce),Yo=dr(en),nn=mr(ce),rn=new WeakMap,qo=gr(rn,K),Zo=Kr(tn,ce,H,ot,Vt,st,te,Je,ie,nn,ct,qo,Le),Ho=zr(H,Zo,te,ie,Le),Ko=sr(Zt,tn,De,ot,Vt,st,te,Yo,nn,ct,Z,Ae,pe,Ht,tt,Go),Qo=vr(Jt),Jo=io(rn),ps=Qt?nr(zo,We,rt,Ko,Ho,z,Qo,se,J,Ae,go,Jo,Mo,Pe):void 0,ms=Lr(H,ie,ho,$o,Re);export{ls as a,ds as b,ps as c,fs as d,hs as e,ms as m};
//# sourceMappingURL=standardized-audio-context-qOBlHMl5.js.map
