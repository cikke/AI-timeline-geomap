{"version":3,"file":"extendable-media-recorder-DiYIi_eR.js","sources":["../../node_modules/extendable-media-recorder/build/es2019/factories/blob-event-factory.js","../../node_modules/extendable-media-recorder/build/es2019/factories/decode-web-m-chunk.js","../../node_modules/extendable-media-recorder/build/es2019/factories/event-target-constructor.js","../../node_modules/extendable-media-recorder/build/es2019/factories/event-target-factory.js","../../node_modules/extendable-media-recorder/build/es2019/factories/invalid-modification-error.js","../../node_modules/extendable-media-recorder/build/es2019/factories/invalid-state-error.js","../../node_modules/extendable-media-recorder/build/es2019/factories/media-recorder-constructor.js","../../node_modules/extendable-media-recorder/build/es2019/factories/native-blob-event-constructor.js","../../node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder-constructor.js","../../node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder-factory.js","../../node_modules/extendable-media-recorder/build/es2019/factories/not-supported-error.js","../../node_modules/extendable-media-recorder/build/es2019/factories/read-element-content.js","../../node_modules/extendable-media-recorder/build/es2019/factories/read-element-type.js","../../node_modules/extendable-media-recorder/build/es2019/factories/read-variable-size-integer.js","../../node_modules/extendable-media-recorder/build/es2019/factories/web-audio-media-recorder.js","../../node_modules/extendable-media-recorder/build/es2019/factories/webm-pcm-media-recorder.js","../../node_modules/extendable-media-recorder/build/es2019/factories/window.js","../../node_modules/extendable-media-recorder/build/es2019/functions/read-variable-size-integer-length.js","../../node_modules/extendable-media-recorder/build/es2019/functions/wrap-event-listener.js","../../node_modules/extendable-media-recorder/build/es2019/module.js"],"sourcesContent":["export const createBlobEventFactory = (nativeBlobEventConstructor) => {\n    return (type, blobEventInit) => {\n        if (nativeBlobEventConstructor === null) {\n            throw new Error('A native BlobEvent could not be created.');\n        }\n        return new nativeBlobEventConstructor(type, blobEventInit);\n    };\n};\n//# sourceMappingURL=blob-event-factory.js.map","export const createDecodeWebMChunk = (readElementContent, readElementType) => {\n    return (dataView, elementType, channelCount) => {\n        const contents = [];\n        let currentElementType = elementType;\n        let offset = 0;\n        while (offset < dataView.byteLength) {\n            if (currentElementType === null) {\n                const lengthAndType = readElementType(dataView, offset);\n                if (lengthAndType === null) {\n                    break;\n                }\n                const { length, type } = lengthAndType;\n                currentElementType = type;\n                offset += length;\n            }\n            else {\n                const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n                if (contentAndLength === null) {\n                    break;\n                }\n                const { content, length } = contentAndLength;\n                currentElementType = null;\n                offset += length;\n                if (content !== null) {\n                    contents.push(content);\n                }\n            }\n        }\n        return { contents, currentElementType, offset };\n    };\n};\n//# sourceMappingURL=decode-web-m-chunk.js.map","export const createEventTargetConstructor = (createEventTarget, wrapEventListener) => {\n    return class EventTarget {\n        constructor(nativeEventTarget = null) {\n            this._listeners = new WeakMap();\n            this._nativeEventTarget = nativeEventTarget === null ? createEventTarget() : nativeEventTarget;\n        }\n        addEventListener(type, listener, options) {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n        dispatchEvent(event) {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n        removeEventListener(type, listener, options) {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n//# sourceMappingURL=event-target-constructor.js.map","export const createEventTargetFactory = (window) => {\n    return () => {\n        if (window === null) {\n            throw new Error('A native EventTarget could not be created.');\n        }\n        return window.document.createElement('p');\n    };\n};\n//# sourceMappingURL=event-target-factory.js.map","export const createInvalidModificationError = (message = '') => {\n    try {\n        return new DOMException(message, 'InvalidModificationError');\n    }\n    catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 13;\n        err.message = message;\n        err.name = 'InvalidModificationError';\n        return err;\n    }\n};\n//# sourceMappingURL=invalid-modification-error.js.map","export const createInvalidStateError = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n    }\n};\n//# sourceMappingURL=invalid-state-error.js.map","export const createMediaRecorderConstructor = (createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) => {\n    return class MediaRecorder extends eventTargetConstructor {\n        constructor(stream, options = {}) {\n            const { mimeType } = options;\n            if (nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                (mimeType === undefined ||\n                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))) {\n                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                super(internalMediaRecorder);\n                this._internalMediaRecorder = internalMediaRecorder;\n            }\n            else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {\n                super();\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                if (nativeMediaRecorderConstructor !== null &&\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {\n                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n                }\n                else {\n                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n                }\n            }\n            else {\n                // This is creating a native MediaRecorder just to provoke it to throw an error.\n                if (nativeMediaRecorderConstructor !== null) {\n                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                }\n                throw createNotSupportedError();\n            }\n            this._ondataavailable = null;\n            this._onerror = null;\n            this._onpause = null;\n            this._onresume = null;\n            this._onstart = null;\n            this._onstop = null;\n        }\n        get mimeType() {\n            return this._internalMediaRecorder.mimeType;\n        }\n        get ondataavailable() {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n        }\n        set ondataavailable(value) {\n            if (this._ondataavailable !== null) {\n                this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('dataavailable', boundListener);\n                this._ondataavailable = [value, boundListener];\n            }\n            else {\n                this._ondataavailable = null;\n            }\n        }\n        get onerror() {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n        }\n        set onerror(value) {\n            if (this._onerror !== null) {\n                this.removeEventListener('error', this._onerror[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('error', boundListener);\n                this._onerror = [value, boundListener];\n            }\n            else {\n                this._onerror = null;\n            }\n        }\n        get onpause() {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n        }\n        set onpause(value) {\n            if (this._onpause !== null) {\n                this.removeEventListener('pause', this._onpause[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('pause', boundListener);\n                this._onpause = [value, boundListener];\n            }\n            else {\n                this._onpause = null;\n            }\n        }\n        get onresume() {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n        }\n        set onresume(value) {\n            if (this._onresume !== null) {\n                this.removeEventListener('resume', this._onresume[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('resume', boundListener);\n                this._onresume = [value, boundListener];\n            }\n            else {\n                this._onresume = null;\n            }\n        }\n        get onstart() {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n        }\n        set onstart(value) {\n            if (this._onstart !== null) {\n                this.removeEventListener('start', this._onstart[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('start', boundListener);\n                this._onstart = [value, boundListener];\n            }\n            else {\n                this._onstart = null;\n            }\n        }\n        get onstop() {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n        }\n        set onstop(value) {\n            if (this._onstop !== null) {\n                this.removeEventListener('stop', this._onstop[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('stop', boundListener);\n                this._onstop = [value, boundListener];\n            }\n            else {\n                this._onstop = null;\n            }\n        }\n        get state() {\n            return this._internalMediaRecorder.state;\n        }\n        pause() {\n            return this._internalMediaRecorder.pause();\n        }\n        resume() {\n            return this._internalMediaRecorder.resume();\n        }\n        start(timeslice) {\n            return this._internalMediaRecorder.start(timeslice);\n        }\n        stop() {\n            return this._internalMediaRecorder.stop();\n        }\n        static isTypeSupported(mimeType) {\n            return ((nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||\n                encoderRegexes.some((regex) => regex.test(mimeType)));\n        }\n    };\n};\n//# sourceMappingURL=media-recorder-constructor.js.map","export const createNativeBlobEventConstructor = (window) => {\n    if (window !== null && window.BlobEvent !== undefined) {\n        return window.BlobEvent;\n    }\n    return null;\n};\n//# sourceMappingURL=native-blob-event-constructor.js.map","export const createNativeMediaRecorderConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return window.MediaRecorder === undefined ? null : window.MediaRecorder;\n};\n//# sourceMappingURL=native-media-recorder-constructor.js.map","export const createNativeMediaRecorderFactory = (createNotSupportedError) => (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n    const bufferedBlobEventListeners = new Map();\n    const dataAvailableListeners = new WeakMap();\n    const errorListeners = new WeakMap();\n    const flags = [];\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n    const stopListeners = new WeakMap();\n    nativeMediaRecorder.addEventListener('stop', ({ isTrusted }) => {\n        if (isTrusted) {\n            setTimeout(() => flags.shift());\n        }\n    });\n    nativeMediaRecorder.addEventListener = ((addEventListener) => {\n        return (type, listener, options) => {\n            let patchedEventListener = listener;\n            if (typeof listener === 'function') {\n                if (type === 'dataavailable') {\n                    const bufferedBlobEvents = [];\n                    // Bug #20: Firefox dispatches multiple dataavailable events while being inactive.\n                    patchedEventListener = (event) => {\n                        const [[isSliced, isActive] = [false, false]] = flags;\n                        if (isSliced && !isActive) {\n                            bufferedBlobEvents.push(event);\n                        }\n                        else {\n                            listener.call(nativeMediaRecorder, event);\n                        }\n                    };\n                    bufferedBlobEventListeners.set(listener, bufferedBlobEvents);\n                    dataAvailableListeners.set(listener, patchedEventListener);\n                }\n                else if (type === 'error') {\n                    // Bug #12 & #13: Firefox fires a regular event with an error property.\n                    patchedEventListener = (event) => {\n                        if (event instanceof ErrorEvent) {\n                            listener.call(nativeMediaRecorder, event);\n                        }\n                        else {\n                            listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: event.error }));\n                        }\n                    };\n                    errorListeners.set(listener, patchedEventListener);\n                }\n                else if (type === 'stop') {\n                    // Bug #20: Firefox dispatches multiple dataavailable events while being inactive.\n                    patchedEventListener = (event) => {\n                        for (const [dataAvailableListener, bufferedBlobEvents] of bufferedBlobEventListeners.entries()) {\n                            if (bufferedBlobEvents.length > 0) {\n                                const [blobEvent] = bufferedBlobEvents;\n                                if (bufferedBlobEvents.length > 1) {\n                                    Object.defineProperty(blobEvent, 'data', {\n                                        value: new Blob(bufferedBlobEvents.map(({ data }) => data), { type: blobEvent.data.type })\n                                    });\n                                }\n                                bufferedBlobEvents.length = 0;\n                                dataAvailableListener.call(nativeMediaRecorder, blobEvent);\n                            }\n                        }\n                        listener.call(nativeMediaRecorder, event);\n                    };\n                    stopListeners.set(listener, patchedEventListener);\n                }\n            }\n            return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n        };\n    })(nativeMediaRecorder.addEventListener);\n    nativeMediaRecorder.removeEventListener = ((removeEventListener) => {\n        return (type, listener, options) => {\n            let patchedEventListener = listener;\n            if (typeof listener === 'function') {\n                if (type === 'dataavailable') {\n                    bufferedBlobEventListeners.delete(listener);\n                    const dataAvailableListener = dataAvailableListeners.get(listener);\n                    if (dataAvailableListener !== undefined) {\n                        patchedEventListener = dataAvailableListener;\n                    }\n                }\n                else if (type === 'error') {\n                    const errorListener = errorListeners.get(listener);\n                    if (errorListener !== undefined) {\n                        patchedEventListener = errorListener;\n                    }\n                }\n                else if (type === 'stop') {\n                    const stopListener = stopListeners.get(listener);\n                    if (stopListener !== undefined) {\n                        patchedEventListener = stopListener;\n                    }\n                }\n            }\n            return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n        };\n    })(nativeMediaRecorder.removeEventListener);\n    nativeMediaRecorder.start = ((start) => {\n        return (timeslice) => {\n            /*\n             * Bug #6: Safari will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n             * codec.\n             */\n            if (mediaRecorderOptions.mimeType !== undefined &&\n                mediaRecorderOptions.mimeType.startsWith('audio/') &&\n                stream.getVideoTracks().length > 0) {\n                throw createNotSupportedError();\n            }\n            if (nativeMediaRecorder.state === 'inactive') {\n                flags.push([timeslice !== undefined, true]);\n            }\n            return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n        };\n    })(nativeMediaRecorder.start);\n    nativeMediaRecorder.stop = ((stop) => {\n        return () => {\n            if (nativeMediaRecorder.state !== 'inactive') {\n                flags[0][1] = false;\n            }\n            stop.call(nativeMediaRecorder);\n        };\n    })(nativeMediaRecorder.stop);\n    return nativeMediaRecorder;\n};\n//# sourceMappingURL=native-media-recorder-factory.js.map","export const createNotSupportedError = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    }\n    catch (err) {\n        // @todo Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n    }\n};\n//# sourceMappingURL=not-supported-error.js.map","export const createReadElementContent = (readVariableSizeInteger) => {\n    return (dataView, offset, type, channelCount = 2) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n        const { length, value } = lengthAndValue;\n        if (type === 'master') {\n            return { content: null, length };\n        }\n        if (offset + length + value > dataView.byteLength) {\n            return null;\n        }\n        if (type === 'binary') {\n            const numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n            const content = Array.from({ length: channelCount }, () => new Float32Array(numberOfSamples));\n            for (let i = 0; i < numberOfSamples; i += 1) {\n                const elementOffset = i * channelCount + 1;\n                for (let j = 0; j < channelCount; j += 1) {\n                    content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n                }\n            }\n            return { content, length: length + value };\n        }\n        return { content: null, length: length + value };\n    };\n};\n//# sourceMappingURL=read-element-content.js.map","export const createReadElementType = (readVariableSizeInteger) => {\n    return (dataView, offset) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n        const { length, value } = lengthAndValue;\n        if (value === 35) {\n            return { length, type: 'binary' };\n        }\n        if (value === 46 ||\n            value === 97 ||\n            value === 88713574 ||\n            value === 106212971 ||\n            value === 139690087 ||\n            value === 172351395 ||\n            value === 256095861) {\n            return { length, type: 'master' };\n        }\n        return { length, type: 'unknown' };\n    };\n};\n//# sourceMappingURL=read-element-type.js.map","export const createReadVariableSizeInteger = (readVariableSizeIntegerLength) => {\n    return (dataView, offset) => {\n        const length = readVariableSizeIntegerLength(dataView, offset);\n        if (length === null) {\n            return length;\n        }\n        const firstDataByteOffset = offset + Math.floor((length - 1) / 8);\n        if (firstDataByteOffset + length > dataView.byteLength) {\n            return null;\n        }\n        const firstDataByte = dataView.getUint8(firstDataByteOffset);\n        let value = firstDataByte & ((1 << (8 - (length % 8))) - 1); // tslint:disable-line:no-bitwise\n        for (let i = 1; i < length; i += 1) {\n            value = (value << 8) + dataView.getUint8(firstDataByteOffset + i); // tslint:disable-line:no-bitwise\n        }\n        return { length, value };\n    };\n};\n//# sourceMappingURL=read-variable-size-integer.js.map","import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderInstanceIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n    const { encoderInstanceId, port } = await instantiate(mimeType, audioContext.sampleRate);\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n    return { audioBufferSourceNode, encoderInstanceId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        var _a;\n        const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n            return addAudioWorkletModule(audioContext, url);\n        });\n        let abortRecording = null;\n        let intervalId = null;\n        let promisedAudioNodesAndEncoderInstanceId = null;\n        let promisedPartialRecording = null;\n        let isAudioContextRunning = true;\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n        const requestNextPartialRecording = async (encoderInstanceId, timeslice) => {\n            const arrayBuffers = await encode(encoderInstanceId, timeslice);\n            if (promisedAudioNodesAndEncoderInstanceId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            }\n            else {\n                dispatchDataAvailableEvent(arrayBuffers);\n                promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n            }\n        };\n        const resume = () => {\n            isAudioContextRunning = true;\n            return audioContext.resume();\n        };\n        const stop = () => {\n            if (promisedAudioNodesAndEncoderInstanceId === null) {\n                return;\n            }\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n            promisedAudioNodesAndEncoderInstanceId.then(async ({ encoderInstanceId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(() => {\n                        /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                }\n                await recorderAudioWorkletNode.stop();\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                const arrayBuffers = await encode(encoderInstanceId, null);\n                if (promisedAudioNodesAndEncoderInstanceId === null) {\n                    await suspend();\n                }\n                dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                bufferedArrayBuffers.length = 0;\n                eventTarget.dispatchEvent(new Event('stop'));\n            });\n            promisedAudioNodesAndEncoderInstanceId = null;\n        };\n        const suspend = () => {\n            isAudioContextRunning = false;\n            return audioContext.suspend();\n        };\n        suspend();\n        return {\n            get mimeType() {\n                return mimeType;\n            },\n            get state() {\n                return promisedAudioNodesAndEncoderInstanceId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n            pause() {\n                if (promisedAudioNodesAndEncoderInstanceId === null) {\n                    throw createInvalidStateError();\n                }\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n            resume() {\n                if (promisedAudioNodesAndEncoderInstanceId === null) {\n                    throw createInvalidStateError();\n                }\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n            start(timeslice) {\n                var _a;\n                if (promisedAudioNodesAndEncoderInstanceId !== null) {\n                    throw createInvalidStateError();\n                }\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n                eventTarget.dispatchEvent(new Event('start'));\n                const audioTracks = mediaStream.getAudioTracks();\n                const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n                promisedAudioNodesAndEncoderInstanceId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderInstanceIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))\n                ]).then(async ([, { audioBufferSourceNode, encoderInstanceId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n                    await recorderAudioWorkletNode.record(port);\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n                    }\n                    return { encoderInstanceId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n                const tracks = mediaStream.getTracks();\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n                    if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n            stop\n        };\n    };\n};\n//# sourceMappingURL=web-audio-media-recorder.js.map","import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, decodeWebMChunk, readVariableSizeInteger) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const bufferedArrayBuffers = [];\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        let promisedPartialRecording = null;\n        let stopRecording = () => { }; // tslint:disable-line:no-empty\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n        const requestNextPartialRecording = async (encoderInstanceId, timeslice) => {\n            const arrayBuffers = await encode(encoderInstanceId, timeslice);\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            }\n            else {\n                dispatchDataAvailableEvent(arrayBuffers);\n                promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n            }\n        };\n        const stop = () => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n            stopRecording();\n            stopRecording = () => { }; // tslint:disable-line:no-empty\n            nativeMediaRecorder.stop();\n        };\n        nativeMediaRecorder.addEventListener('error', (event) => {\n            stop();\n            eventTarget.dispatchEvent(new ErrorEvent('error', {\n                error: event.error\n            }));\n        });\n        nativeMediaRecorder.addEventListener('pause', () => eventTarget.dispatchEvent(new Event('pause')));\n        nativeMediaRecorder.addEventListener('resume', () => eventTarget.dispatchEvent(new Event('resume')));\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n        return {\n            get mimeType() {\n                return mimeType;\n            },\n            get state() {\n                return nativeMediaRecorder.state;\n            },\n            pause() {\n                return nativeMediaRecorder.pause();\n            },\n            resume() {\n                return nativeMediaRecorder.resume();\n            },\n            start(timeslice) {\n                const [audioTrack] = mediaStream.getAudioTracks();\n                if (audioTrack !== undefined && nativeMediaRecorder.state === 'inactive') {\n                    // Bug #19: Chrome does not expose the correct channelCount property right away.\n                    const { channelCount, sampleRate } = audioTrack.getSettings();\n                    if (channelCount === undefined) {\n                        throw new Error('The channelCount is not defined.');\n                    }\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderInstanceIdAndPort = instantiate(mimeType, sampleRate);\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n                    const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({ data }) => {\n                        pendingInvocations += 1;\n                        const promisedArrayBuffer = data.arrayBuffer();\n                        promisedDataViewElementTypeEncoderInstanceIdAndPort = promisedDataViewElementTypeEncoderInstanceIdAndPort.then(async ({ dataView = null, elementType = null, encoderInstanceId, port }) => {\n                            const arrayBuffer = await promisedArrayBuffer;\n                            pendingInvocations -= 1;\n                            const currentDataView = dataView === null\n                                ? new MultiBufferDataView([arrayBuffer])\n                                : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n                            if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n                                if (lengthAndValue === null) {\n                                    return { dataView: currentDataView, elementType, encoderInstanceId, port };\n                                }\n                                const { value } = lengthAndValue;\n                                if (value !== 172351395) {\n                                    return { dataView, elementType, encoderInstanceId, port };\n                                }\n                                isRecording = true;\n                            }\n                            const { currentElementType, offset, contents } = decodeWebMChunk(currentDataView, elementType, channelCount);\n                            const remainingDataView = offset < currentDataView.byteLength\n                                ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                : null;\n                            contents.forEach((content) => port.postMessage(content, content.map(({ buffer }) => buffer)));\n                            if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                encode(encoderInstanceId, null).then((arrayBuffers) => {\n                                    dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                                    bufferedArrayBuffers.length = 0;\n                                    eventTarget.dispatchEvent(new Event('stop'));\n                                });\n                                port.postMessage([]);\n                                port.close();\n                                removeEventListener();\n                            }\n                            return { dataView: remainingDataView, elementType: currentElementType, encoderInstanceId, port };\n                        });\n                    });\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderInstanceIdAndPort.then(({ encoderInstanceId }) => {\n                            if (isStopped) {\n                                return;\n                            }\n                            promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n                        });\n                    }\n                }\n                nativeMediaRecorder.start(100);\n            },\n            stop\n        };\n    };\n};\n//# sourceMappingURL=webm-pcm-media-recorder.js.map","export const createWindow = () => (typeof window === 'undefined' ? null : window);\n//# sourceMappingURL=window.js.map","export const readVariableSizeIntegerLength = (dataView, offset) => {\n    if (offset >= dataView.byteLength) {\n        return null;\n    }\n    const byte = dataView.getUint8(offset);\n    if (byte > 127) {\n        return 1;\n    }\n    if (byte > 63) {\n        return 2;\n    }\n    if (byte > 31) {\n        return 3;\n    }\n    if (byte > 15) {\n        return 4;\n    }\n    if (byte > 7) {\n        return 5;\n    }\n    if (byte > 3) {\n        return 6;\n    }\n    if (byte > 1) {\n        return 7;\n    }\n    if (byte > 0) {\n        return 8;\n    }\n    const length = readVariableSizeIntegerLength(dataView, offset + 1);\n    return length === null ? null : length + 8;\n};\n//# sourceMappingURL=read-variable-size-integer-length.js.map","export const wrapEventListener = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n//# sourceMappingURL=wrap-event-listener.js.map","import { deregister as drgstr, register as rgstr } from 'media-encoder-host';\nimport { createBlobEventFactory } from './factories/blob-event-factory';\nimport { createDecodeWebMChunk } from './factories/decode-web-m-chunk';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createEventTargetFactory } from './factories/event-target-factory';\nimport { createInvalidModificationError } from './factories/invalid-modification-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaRecorderConstructor } from './factories/media-recorder-constructor';\nimport { createNativeBlobEventConstructor } from './factories/native-blob-event-constructor';\nimport { createNativeMediaRecorderConstructor } from './factories/native-media-recorder-constructor';\nimport { createNativeMediaRecorderFactory } from './factories/native-media-recorder-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createReadElementContent } from './factories/read-element-content';\nimport { createReadElementType } from './factories/read-element-type';\nimport { createReadVariableSizeInteger } from './factories/read-variable-size-integer';\nimport { createWebAudioMediaRecorderFactory } from './factories/web-audio-media-recorder';\nimport { createWebmPcmMediaRecorderFactory } from './factories/webm-pcm-media-recorder';\nimport { createWindow } from './factories/window';\nimport { readVariableSizeIntegerLength } from './functions/read-variable-size-integer-length';\nimport { wrapEventListener } from './functions/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\nconst encoderRegexes = [];\nconst window = createWindow();\nconst nativeBlobEventConstructor = createNativeBlobEventConstructor(window);\nconst createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);\nconst createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError);\nconst readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);\nconst readElementContent = createReadElementContent(readVariableSizeInteger);\nconst readElementType = createReadElementType(readVariableSizeInteger);\nconst decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);\nconst createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(createBlobEvent, decodeWebMChunk, readVariableSizeInteger);\nconst createEventTarget = createEventTargetFactory(window);\nconst nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window);\nconst mediaRecorderConstructor = createMediaRecorderConstructor(createNativeMediaRecorderFactory(createNotSupportedError), createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, createEventTargetConstructor(createEventTarget, wrapEventListener), nativeMediaRecorderConstructor);\nexport { mediaRecorderConstructor as MediaRecorder };\nconst ports = new WeakMap();\nexport const deregister = async (port) => {\n    await drgstr(port);\n    const encoderRegex = ports.get(port);\n    if (encoderRegex !== undefined) {\n        const index = encoderRegexes.indexOf(encoderRegex);\n        encoderRegexes.splice(index, 1);\n    }\n};\nexport const isSupported = () => createIsSupportedPromise(window);\nexport const register = async (port) => {\n    const encoderRegex = await rgstr(port);\n    encoderRegexes.push(encoderRegex);\n    ports.set(port, encoderRegex);\n};\n//# sourceMappingURL=module.js.map"],"names":["createBlobEventFactory","nativeBlobEventConstructor","type","blobEventInit","createDecodeWebMChunk","readElementContent","readElementType","dataView","elementType","channelCount","contents","currentElementType","offset","lengthAndType","length","contentAndLength","content","createEventTargetConstructor","createEventTarget","wrapEventListener","nativeEventTarget","listener","options","wrappedEventListener","event","createEventTargetFactory","window","createInvalidModificationError","message","err","createInvalidStateError","createMediaRecorderConstructor","createNativeMediaRecorder","createNotSupportedError","createWebAudioMediaRecorder","createWebmPcmMediaRecorder","encoderRegexes","eventTargetConstructor","nativeMediaRecorderConstructor","stream","mimeType","internalMediaRecorder","regex","value","boundListener","timeslice","createNativeBlobEventConstructor","createNativeMediaRecorderConstructor","createNativeMediaRecorderFactory","mediaRecorderOptions","bufferedBlobEventListeners","dataAvailableListeners","errorListeners","flags","nativeMediaRecorder","stopListeners","isTrusted","addEventListener","patchedEventListener","bufferedBlobEvents","isSliced","isActive","dataAvailableListener","blobEvent","data","removeEventListener","errorListener","stopListener","start","stop","createReadElementContent","readVariableSizeInteger","lengthAndValue","numberOfSamples","i","elementOffset","j","createReadElementType","createReadVariableSizeInteger","readVariableSizeIntegerLength","firstDataByteOffset","ERROR_MESSAGE","createPromisedAudioNodesEncoderInstanceIdAndPort","audioBuffer","audioContext","mediaStream","encoderInstanceId","port","instantiate","AudioWorkletNode","audioBufferSourceNode","AudioBufferSourceNode","mediaStreamAudioSourceNode","MediaStreamAudioSourceNode","recorderAudioWorkletNode","createRecorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","eventTarget","_a","sampleRate","MinimalAudioContext","AudioBuffer","bufferedArrayBuffers","promisedAudioWorkletModule","addRecorderAudioWorkletModule","url","addAudioWorkletModule","abortRecording","intervalId","promisedAudioNodesAndEncoderInstanceId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","arrayBuffers","requestNextPartialRecording","encode","resume","suspend","audioTracks","resolve","tracks","currentTracks","track","index","createWebmPcmMediaRecorderFactory","decodeWebMChunk","stopRecording","audioTrack","isRecording","isStopped","pendingInvocations","promisedDataViewElementTypeEncoderInstanceIdAndPort","on","promisedArrayBuffer","arrayBuffer","currentDataView","MultiBufferDataView","remainingDataView","buffer","createWindow","byte","target","eventListener","descriptor","mediaRecorderConstructor"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}