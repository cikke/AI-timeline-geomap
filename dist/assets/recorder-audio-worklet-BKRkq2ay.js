import{g as l}from"./fast-unique-numbers-DPbHlSK3.js";import{o as _}from"./subscribable-things-Cegrwan0.js";const g=(t,e,r)=>async s=>{const a=new t([r],{type:"application/javascript; charset=utf-8"}),o=e.createObjectURL(a);try{await s(o)}finally{e.revokeObjectURL(o)}},m=t=>({data:e})=>{const{id:r}=e;if(r!==null){const s=t.get(r);if(s!==void 0){const{reject:a,resolve:o}=s;t.delete(r),e.error===void 0?o(e.result):a(new Error(e.error.message))}}},f=t=>(e,r)=>(s,a=[])=>new Promise((o,c)=>{const n=t(e);e.set(n,{reject:c,resolve:o}),r.postMessage({id:n,...s},a)}),w=(t,e,r,s)=>(a,o,c={})=>{const n=new a(o,"recorder-audio-worklet-processor",{...c,channelCountMode:"explicit",numberOfInputs:1,numberOfOutputs:0}),u=new Map,d=e(u,n.port),p=r(n.port,"message")(t(u));n.port.start();let i="inactive";return Object.defineProperties(n,{pause:{get(){return async()=>(s(["recording"],i),i="paused",d({method:"pause"}))}},port:{get(){throw new Error("The port of a RecorderAudioWorkletNode can't be accessed.")}},record:{get(){return async h=>(s(["inactive"],i),i="recording",d({method:"record",params:{encoderPort:h}},[h]))}},resume:{get(){return async()=>(s(["paused"],i),i="recording",d({method:"resume"}))}},stop:{get(){return async()=>{s(["paused","recording"],i),i="stopped";try{await d({method:"stop"})}finally{p()}}}}}),n},b=(t,e)=>{if(!t.includes(e))throw new Error(`Expected the state to be ${t.map(r=>`"${r}"`).join(" or ")} but it was "${e}".`)},k='(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._numberOfChannels=0,this._state="inactive",this.port.onmessage=e=>{let{data:t}=e;"pause"===t.method?"active"===this._state||"recording"===this._state?(this._state="paused",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"record"===t.method?"inactive"===this._state?(this._encoderPort=t.params.encoderPort,this._state="active",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"resume"===t.method?"paused"===this._state?(this._state="active",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"stop"===t.method?"active"!==this._state&&"paused"!==this._state&&"recording"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(t.id):(this._stop(this._encoderPort),this._sendAcknowledgement(t.id)):"number"==typeof t.id&&this.port.postMessage({error:{code:-32601,message:"The requested method is not supported."},id:t.id})}}process(e){let[t]=e;if("inactive"===this._state||"paused"===this._state)return!0;if("active"===this._state){if(void 0===t)throw new Error("No channelData was received for the first input.");if(0===t.length)return!0;this._state="recording"}if("recording"===this._state&&null!==this._encoderPort){if(void 0===t)throw new Error("No channelData was received for the first input.");return 0===t.length?this._encoderPort.postMessage(Array.from({length:this._numberOfChannels},(()=>128))):(this._encoderPort.postMessage(t,t.map((e=>{let{buffer:t}=e;return t}))),this._numberOfChannels=t.length),!0}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:"The internal state does not allow to process the given message."},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state="stopped"}}e.parameterDescriptors=[],registerProcessor("recorder-audio-worklet-processor",e)})();',A=g(Blob,URL,k),M=w(m,f(l),_,b);export{A as a,M as c};
//# sourceMappingURL=recorder-audio-worklet-BKRkq2ay.js.map
